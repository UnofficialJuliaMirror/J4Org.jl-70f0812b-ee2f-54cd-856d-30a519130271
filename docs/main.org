#+SETUPFILE: ./Setup/setupFile.org
#+AUTHOR: Vincent Picaud
#+PROPERTY: header-args:julia :session *JuliaDoc_session* :exports code :eval no-export
#+HTML_HEAD_EXTRA: <style type="text/css"> blockquote {background:#EEEEEE; padding: 3px 13px}    </style>
#+HTML_HEAD_EXTRA: <style type="text/css"> pre {background:#EEEEEE; padding: 3px 13px}    </style>
#+TITLE: Package Documentation

#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[]{
  bgcolor=bg,
  breaklines=true,
  breakanywhere=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

#+BEGIN_SRC julia :results output none :eval no-export :exports none
using Revise
using J4Org
initialize_boxing_module(boxingModule="J4OrgBoxing",usedModules=["J4Org"],force=true)
cd(expanduser("~/GitHub/J4Org.jl/docs/"))
#+END_SRC

# Also use Foo as example 
#+BEGIN_SRC julia :results output none :eval no-export :exports none
push!(LOAD_PATH,pwd()*"/minimal_example/")
initialize_boxing_module(usedModules=["Foo"],force=true)
#+END_SRC

* Introduction

J4Org.jl is a Julia package that allows Julia doc generation into an
Org-Mode document. The goal is to be able to code and document Julia
packages without leaving Emacs and to reduce as much as possible the
burden of documentation. This package depends on [[https://github.com/KristofferC/Tokenize.jl/][Tokenize.jl]], to
tokenize Julia code.

** Minimal requirements 

You need [[https://orgmode.org/][Org-Mode]] plus [[https://github.com/gjkerns/ob-julia/blob/master/ob-julia-doc.org][ob-julia.el]], which has [[http://stat.ethz.ch/ESS/index.php?Section=download][ESS]] as dependence, to be
installed.

** Getting started with a minimal example

The following is a minimal example you can reproduce to have a taste
of what this package do.

*** Emacs configuration

You first need a minimal =init.el= file to configure Emacs.

#+BEGIN_SRC emacs-lisp :eval never :tangle yes :tangle minimal_example/init.el
(package-initialize)

(require 'ess-site)
;; if required
;; (setq  inferior-julia-program-name "/path/to/julia-release-basic")

(require 'org)
;; *replace me* with your own ob-julia.el file location 
(add-to-list 'load-path "~/GitLab/WorkingWithOrgMode/EmacsFiles")
;; babel configuration
(setq org-confirm-babel-evaluate nil)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((julia . t)))
#+END_SRC

#+RESULTS:

*** A documented Julia =Foo= module
    :PROPERTIES:
    :ID:       2ae4bb8f-17f2-4cb7-9fba-eff22bea6a92
    :END:

Then you need a documented module:

#+BEGIN_SRC julia :eval never :tangle yes :tangle minimal_example/Foo.jl
module Foo

export Point, foo
    
import Base: norm

#+Point L:Point_struct
# This is my Point structure
#
# *Example:*
#
# Creates a point $p$ of coordinates $(x=1,y=2)$.
#
# #+BEGIN_SRC julia :eval never :exports code
# p=Point(1,2)
# #+END_SRC
#
# You can add any valid Org mode directive. If you want to use
# in-documentation link, use [[norm_link_example][]]
#
struct Point
    x::Float64
    y::Float64
end

#+Point
# Creates Point at origin $(0,0)$ 
Point() = Point(0,0)

#+Enum
# An enum
@enum Alpha A=1 B C # just for example

#+Point,Method L:norm_link_example
# A simple function that computes $\sqrt{x^2+y^2}$
#
# *Example:*
#!p=Point(1.0,2.0);
#!norm(p) 
#
# See: [[Point_struct][]]
#
norm(p::Point)::Float64 = sqrt(p.x*p.x+p.y*p.y)

# +Method,Internal
# An internal function
#
# For symbol that are not exported, do not forget the "Foo." prefix:
# !p=Point(1.0,2.0)
# !Foo.foo(2.0,p)
foo(r::Float64,p::Point) = Point(r*p.x,r*p.y)

end 
#+END_SRC

I wanted to reduce the documentation process as much as possible. The
template is very simple. Before each item you want to document add
these comment lines:

#+BEGIN_SRC julia :eval never :exports code 
#+Tag1,Tag2,... L:an_extra_link_if_required 
#
# Here you can put any Org mode text, for instance $sin(x)$
#
#!sin(5) # julia code to be executed
#
# [[internal_link][]]
struct A_Documented_Struct 
...
end 
#+END_SRC

- *#+Tag1,Tag2,...* is mandatory, "#+" is followed by a list of
  tags. Later when you want to extract doc you can do filtering
  according these tags.

- *L:an_extra_link_if_required* is *not* mandatory. It defines a
  reference if you want to create doc links. The previous statement
  defines a link *target* named =an_extra_link_if_required=.

- *[[internal_link][]]* creates a link to a previously defined
  *L:internal_link*.

- *!sin(5)* will execute Julia code and include the output in the
  doc. If you only want to include Julia code without executing it,
  simply use Org mode source block:
#+BEGIN_SRC julia :eval never :exports code 
# #+BEGIN_SRC julia :eval never :exports code
# sin(5)
# #+END_SRC
#+END_SRC

**** Support for "# +" and "# !" (since v0.2.0)

As you can see (foo() function comments), "# \plus", "#\plus" and "#
!", "#!" are synonyms.  The motivation is a better integration with
[[https://github.com/QBobWatson/poporg][poporg]] Emacs package.  With this Emacs package you can edit comment
under OrgMode mode without being bothered by the "#" characters.

*** Minimal OrgMode document

This is the =foo.org= file.

# I use bash instead of org, othewise PDF export is not working properly.
#+BEGIN_SRC org :eval never :tangle yes :tangle minimal_example/foo.org 
,#+PROPERTY: header-args:julia :session *my_session* :exports code :eval no-export
,#+OPTIONS: ^:{}
,#+TITLE: Getting Started with a minimal example

,#+BEGIN_SRC julia :results output none :eval no-export :exports none
push!(LOAD_PATH,pwd())
,#+END_SRC

,#+BEGIN_SRC julia :results output none :eval no-export :exports none
using J4Org 
initialize_boxing_module(usedModules=["Foo"]) 
documented_items=create_documented_item_array("Foo.jl")
,#+END_SRC

,* Example

Prints all documented items, except those tagged with "Internal" 
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
print_org_doc(documented_items,tag_to_ignore=["Internal"],header_level=0)
,#+END_SRC
#+END_SRC

#+RESULTS:


- *push!(LOAD_PATH,pwd())* tells Julia where it can find our local =Foo=
  module. This statement is only required if the documented module is
  in an unusual place.

- *using J4Org* uses this package

- *initialize_boxing_module(usedModules=["Foo"])* defines what are
  the modules to use when executing Julia code extracted from the doc
  (the "#!" statements). Here we are documenting the =Foo= module,
  hence we must use it. Note that you can also use any number of extra
  modules for instance with =["Foo", "ExtraModule", ...]=. See
  [[API_initialize_boxing_module][initialize_boxing_module(...)]] for further details.

- *create_documented_item_array("Foo.jl")* creates the list of
  documented items from file "Foo.jl". You can use a list of files and
  a directory, see [[API_create_documented_item_array_filename][create_documented_item_array(...)]] for further details.

- *print_org_doc(documented_items,tag_to_ignore=["Internal"],header_level=0)*
  prints all documented items, except those tagged with "Internal",
  see [[API_print_org_doc_API][print_org_doc(...)]] for further details

*** Generating the doc

To check that it works you can start a fresh emacs with

#+BEGIN_SRC bash :eval never
emacs -q --load init.el foo.org &
#+END_SRC

#+RESULTS:

then type:
- =C-c C-v b= + =RET= to execute all source code blocks
- =C-c C-e h o= to html-export the file 
- =C-c C-e l o= to pdf-export the file 

You should get this [[file:minimal_example/foo.html][minimal_example/foo.html]] file.

*** Improving exported document style

This was a minimal example, you can have a better look for the
exported documents by including css theme, etc. This is the approach
we used to generate *this* document (also see the [[file:main.pdf][main.pdf]] PDF file).
Another example is [[https://vincent-picaud.github.io/DirectConvolution.jl/docs.html][DirectConvolution.jl documentation]]. 

* More examples 

We still use our [[id:2ae4bb8f-17f2-4cb7-9fba-eff22bea6a92][=Foo=]] module to provide more examples. The complete [[id:c9053a86-dea5-4bc2-a883-92a1bfde20ba][API]] is detailed after.

** =print_org_doc= options

The [[API_print_org_doc_API][print_org_doc(...)]] function has several options, let's see some usage examples

*** =header_level=

This integer can have these values:
- *-1*: do not print header nor index, see [[id:bda53362-32fb-4096-9c0a-32c0afb96b5f][header_level=-1]]
- *0*: print header beginning with "-", see [[id:842e5c47-62d1-44fc-8489-e105a45f5dd4][header_level=0]].
- *l>0* create subsection of level *l*, for instance *header_level=3*
  creates subsections beginning with *3* stars. See
  [[id:0f6a49dc-ee9f-4964-8801-8badfb67f735][header_level=5]]. *Caveat:* for *l>0* AFAIK there is a bug in OrgMode,
  because a residual *:RESULT:* is printed.

**** header_level=-1
     :PROPERTIES:
     :ID:       bda53362-32fb-4096-9c0a-32c0afb96b5f
     :END:

#+BEGIN_src julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results 
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=-1)
,#+END_SRC
#+END_SRC

This will generate:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results 
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=-1)
#+END_SRC

#+RESULTS:
:RESULTS:


#+BEGIN_SRC julia :eval never :exports code
foo(r::Float64,p::Point)
#+END_SRC
#+BEGIN_QUOTE
An internal function

For symbol that are not exported, do not forget the "Foo." prefix:
#+BEGIN_SRC julia
p=Point(1.0,2.0)
Foo.foo(2.0,p)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia
Foo.Point(1.0, 2.0)
Foo.Point(2.0, 4.0)
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:minimal_example/Foo.jl::46][Foo.jl:46]]
 @@latex:\phantomsection@@  <<RUbly9zKnorm_link_example>>
#+BEGIN_SRC julia :eval never :exports code
norm(p::Point)::Float64
#+END_SRC
#+BEGIN_QUOTE
A simple function that computes $\sqrt{x^2+y^2}$

*Example:*
#+BEGIN_SRC julia
p=Point(1.0,2.0);
norm(p) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia
2.23606797749979
#+END_SRC

#+RESULTS:

See: _struct Point_
#+END_QUOTE
[[file:minimal_example/Foo.jl::35][Foo.jl:35]]
:END:

**** header_level=0
     :PROPERTIES:
     :ID:       842e5c47-62d1-44fc-8489-e105a45f5dd4
     :END:

#+BEGIN_src julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=0)
,#+END_SRC
#+END_SRC

This will generate:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:
2.23606797749979


<<dBCvfWoi>> *Index:* *[f]* [[5c0v1kbs][foo]] *[n]* [[WebpFDJ0][norm]] 
- @@latex:\phantomsection@@ *=foo=*  <<5c0v1kbs>>
#+BEGIN_SRC julia :eval never :exports code
foo(r::Float64,p::Point)
#+END_SRC
#+BEGIN_QUOTE
An internal function

For symbol that are not exported, do not forget the "Foo." prefix:
#+BEGIN_SRC julia
p=Point(1.0,2.0)
Foo.foo(2.0,p)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia
Foo.Point(1.0, 2.0)
Foo.Point(2.0, 4.0)
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:minimal_example/Foo.jl::46][Foo.jl:46]], [[dBCvfWoi][back to index]]
- @@latex:\phantomsection@@ *=norm=*  <<WebpFDJ0>> <<UFoNykVZnorm_link_example>>
#+BEGIN_SRC julia :eval never :exports code
norm(p::Point)::Float64
#+END_SRC
#+BEGIN_QUOTE
A simple function that computes $\sqrt{x^2+y^2}$

*Example:*
#+BEGIN_SRC julia
p=Point(1.0,2.0);
norm(p) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia
2.23606797749979
#+END_SRC

#+RESULTS:
: 2.23606797749979

See: _struct Point_
#+END_QUOTE
[[file:minimal_example/Foo.jl::35][Foo.jl:35]], [[dBCvfWoi][back to index]]
:END:



**** header_level=5
     :PROPERTIES:
     :ID:       0f6a49dc-ee9f-4964-8801-8badfb67f735
     :END:

#+BEGIN_src julia :eval never :exports code 
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=5)
,#+END_SRC
#+END_SRC

This will generate:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=5)
#+END_SRC

#+RESULTS:
:RESULTS:

<<ixVQVKHc>> *Index:* *[f]* [[wGdX72MB][foo]] *[n]* [[okPNhSsO][norm]] 
***** *=foo=*  <<wGdX72MB>>
#+BEGIN_SRC julia :eval never :exports code
foo(r::Float64,p::Point)
#+END_SRC
#+BEGIN_QUOTE
An internal function

For symbol that are not exported, do not forget the "Foo." prefix:
#+BEGIN_SRC julia
p=Point(1.0,2.0)
Foo.foo(2.0,p)
#+END_SRC
#+BEGIN_SRC julia
Foo.Point(1.0, 2.0)
Foo.Point(2.0, 4.0)
#+END_SRC
#+END_QUOTE
[[file:minimal_example/Foo.jl::46][Foo.jl:46]], [[ixVQVKHc][back to index]]
***** *=norm=*  <<okPNhSsO>> <<LO8vGNMEnorm_link_example>>
#+BEGIN_SRC julia :eval never :exports code
norm(p::Point)::Float64
#+END_SRC
#+BEGIN_QUOTE
A simple function that computes $\sqrt{x^2+y^2}$

*Example:*
#+BEGIN_SRC julia
p=Point(1.0,2.0);
norm(p) 
#+END_SRC
#+BEGIN_SRC julia
2.23606797749979
#+END_SRC

See: _struct Point_
#+END_QUOTE
[[file:minimal_example/Foo.jl::35][Foo.jl:35]], [[ixVQVKHc][back to index]]
:END:

*** =tag=, =tag_to_ignore=, =identifier=
    :PROPERTIES:
    :ID:       0e085bd4-7c99-44d6-8220-3e397fff8458
    :END:

These options allow to select items to include:

- =tag= a string or an array of strings, collects all items with at least one tag in this =tag= option.
- =tag_to_ignore= a string or an array of strings, ignore all items with at least one tag in this =tag_to_ignore= option.
- =identifier= a string that stands for the structure, abstract type or function name. Collects all items with this =identifier= name.

For instance we can print =norm= identifier, restricted to =Point= tag, as follows:

#+BEGIN_src julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,identifier="norm", tag="Point",header_level=-1)
,#+END_SRC
#+END_SRC

This will generate:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,identifier="norm", tag="Point",header_level=-1)
#+END_SRC

#+RESULTS:
:RESULTS:

 @@latex:\phantomsection@@  <<e6h2ajhanorm_link_example>>
#+BEGIN_SRC julia :eval never :exports code
norm(p::Point)::Float64
#+END_SRC
#+BEGIN_QUOTE
A simple function that computes $\sqrt{x^2+y^2}$

*Example:*
#+BEGIN_SRC julia
p=Point(1.0,2.0);
norm(p) 
#+END_SRC
#+BEGIN_SRC julia
2.23606797749979
#+END_SRC

See: _struct Point_
#+END_QUOTE
[[file:minimal_example/Foo.jl::35][Foo.jl:35]]
:END:

*** =complete_link=

If you look back at [[id:0e085bd4-7c99-44d6-8220-3e397fff8458][=tag=, =tag_to_ignore=, =identifier=]] you can see,
at the end of the =norm= function documentation, that the
_Point_struct_ link is not active. The reason is that the =Point=
structure is not present. The =complete_link= option, if set to =true=
will try to fix all dangling links by including all the required
documented items. For instance, with:

#+BEGIN_src julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,identifier="norm", tag="Point",header_level=-1,
              complete_link=true)
,#+END_SRC
#+END_SRC

This will generate:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,identifier="norm", tag="Point",header_level=-1,
              complete_link=true)
#+END_SRC

#+RESULTS:
:RESULTS:

 @@latex:\phantomsection@@  <<MVpMsBmwPoint_struct>>
#+BEGIN_SRC julia :eval never :exports code
struct Point
#+END_SRC
#+BEGIN_QUOTE
This is my Point structure

*Example:*

Creates a point $p$ of coordinates $(x=1,y=2)$.

#+BEGIN_SRC julia :eval never :exports code
p=Point(1,2)
#+END_SRC

You can add any valid Org mode directive. If you want to use
in-documentation link, use [[MVpMsBmwnorm_link_example][norm(...)]]
#+END_QUOTE
[[file:minimal_example/Foo.jl::8][Foo.jl:8]]
 @@latex:\phantomsection@@  <<MVpMsBmwnorm_link_example>>
#+BEGIN_SRC julia :eval never :exports code
norm(p::Point)::Float64
#+END_SRC
#+BEGIN_QUOTE
A simple function that computes $\sqrt{x^2+y^2}$

*Example:*
#+BEGIN_SRC julia
p=Point(1.0,2.0);
norm(p) 
#+END_SRC
#+BEGIN_SRC julia
2.23606797749979
#+END_SRC

See: [[MVpMsBmwPoint_struct][struct Point]]
#+END_QUOTE
[[file:minimal_example/Foo.jl::35][Foo.jl:35]]
:END:

you see that the =Point= structure is included to make the
_struct_Point_ link active.

*** =link_prefix=

You can create link from your OrgMode document to Julia documented
items that have defined a "L:link_target". However like these items
can be extracted at several places in your OrgMode document you need
to define a prefix to avoid multiple targets with the same name.

For instance, chose a prefix, here "my_prefix" and use:
#+BEGIN_SRC julia :results none :eval never :exports code
print_org_doc(documented_items,...,link_prefix="my_prefix_")
#+END_SRC
then you can create a regular OrgMode link to this item using
​ *[​[my_prefix_link_target][some_text]]*.


*** =case_sensitive=

When set to true, generates an index as follows:
#+BEGIN_EXAMPLE
[A] ..., [B] ...,[a] ..., [b] ...,
#+END_EXAMPLE

When set to false, do not split upper/lower cases and group all A,a;B,b together:
#+BEGIN_EXAMPLE
[A] ..., [B] ...
#+END_EXAMPLE

*** =boxingModule=

Comments starting with "#!" are executed in a boxed environment
#+BEGIN_SRC julia :eval never 
module MyBoxing
using RequiredPackage_1,RequiredPackage_2,...
end 
#+END_SRC

#+BEGIN_SRC julia :eval never 
using MyBoxing

# execute "#!" statements here
#+END_SRC

This boxing is defined by the [[API_initialize_boxing_module][initialize_boxing_module(...)]] function:

#+BEGIN_SRC julia :eval never
initialize_boxing_module(boxingModule="MyBoxing",
                         usedModules=["RequiredPackage_1","RequiredPackage_2",...])
#+END_SRC

This =boxingModule= option allows you to chose your boxing environment:
#+BEGIN_SRC julia :eval never
print_org_doc(documented_items,boxingModule="MyBoxing",...)
#+END_SRC

** Error reporting
Error reporting is performed as OrgMode comment. For instance if you execute:
#+BEGIN_src julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results 
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=-1)
,#+END_SRC
#+END_SRC


you will get:
#+BEGIN_src julia :eval never :exports code
#+RESULTS:
:RESULTS:
# =WARNING:= Link target ("Point_struct", "") not found
...
:END:
#+END_SRC 
** Compatibility with docstring / documenter.jl
You can still use something like:
#+BEGIN_SRC julia :eval never :exports code
"""
    foo()

foo function ...
"""
#+Tags...
# foo function ...
foo() = ...
#+END_SRC

* API
  :PROPERTIES:
  :ID:       c9053a86-dea5-4bc2-a883-92a1bfde20ba
  :END:

The API is simple, with very few functions:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("../src/");
print_org_doc(documented_items,boxingModule="J4OrgBoxing",tag="API",header_level=0,link_prefix="API_")
#+END_SRC

#+RESULTS:
:RESULTS:

<<aP7ivMRF>> *Index:* *[c]* [[SzN9ZFTx][create_documented_item_array]], [[SNlxPbcS][create_documented_item_array_dir]] *[i]* [[dwazP2ur][initialize_boxing_module]] *[p]* [[bVXaJ4ND][print_org_doc]] 
- @@latex:\phantomsection@@ *=create_documented_item_array=*  <<SzN9ZFTx>> <<API_create_documented_item_array_filename>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename::String)::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a Julia code file and returns an array of documented items.
#+END_QUOTE
[[file:../src/documented_item.jl::95][documented_item.jl:95]], [[aP7ivMRF][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename_list::Array{String,1})::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads an array of Julia code files and returns an array of
documented items.

*Usage example:* 
#+BEGIN_SRC julia
create_documented_item_array(["file1","file2",...])
#+END_SRC

*Note:* instead of a list of files you can also specify a directory,
see [[API_create_documented_item_array_dir][create_documented_item_array_dir(...)]]
#+END_QUOTE
[[file:../src/documented_item.jl::134][documented_item.jl:134]], [[aP7ivMRF][back to index]]
- @@latex:\phantomsection@@ *=create_documented_item_array_dir=*  <<SNlxPbcS>> <<API_create_documented_item_array_dir>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array_dir(dirname::String)
#+END_SRC
#+BEGIN_QUOTE
Reads all *.jl files in a directory and returns an array of
documented items.
#+END_QUOTE
[[file:../src/documented_item.jl::156][documented_item.jl:156]], [[aP7ivMRF][back to index]]
- @@latex:\phantomsection@@ *=initialize_boxing_module=*  <<dwazP2ur>> <<API_initialize_boxing_module>>
#+BEGIN_SRC julia :eval never :exports code
function initialize_boxing_module(;
                                  boxingModule::String="BoxingModule",
                                  usedModules::Vector{String}=String[],
                                  force::Bool=false)::Void
#+END_SRC
#+BEGIN_QUOTE
Initialize a boxing module. This module is used to run Julia comment
code snippet (tagged by "#!" or by "# !")

*Example:*
#+BEGIN_SRC julia :eval never :exports code
initialize_boxing_module(boxingModule="MyBoxing",
                         usedModules=["RequiredPackage_1",
                                      "RequiredPackage_2",...])
#+END_SRC

creates

#+BEGIN_SRC julia :eval never :exports code
module MyBoxing
using RequiredPackage_1,RequiredPackage_2,...
end 
#+END_SRC

and future "# !" statements are executed after using MyBoxing:
#+BEGIN_SRC julia :eval never :exports code
using MyBoxing
# !statements
#+END_SRC
#+END_QUOTE
[[file:../src/evaluate.jl::18][evaluate.jl:18]], [[aP7ivMRF][back to index]]
- @@latex:\phantomsection@@ *=print_org_doc=*  <<bVXaJ4ND>> <<API_print_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule")
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_SRC julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(documented_items,tag="API",header_level=0)
,#+END_SRC
#+END_SRC

*Arguments:*
- =tag=: tags to collect when generating the documentation
- =tag_to_ignore=: tags to ignore when generating the documentation
- =identifier=: generates documentation for this "identifier". Can be a function name, a structure name, etc…
- =link_prefix=: allows to add a prefix to extra link (#+tag L=extra_link). this is can be useful to avoid link name conflict when performing local doc extraction.
- =complete_link=: if true, try to fix link without target by adding extra items
- =case_sensitive=: case sensitive index.
- =boxingModule=: specifies the context in which "#!" code will be executed. See [[API_initialize_boxing_module][initialize_boxing_module(...)]] for details.
#+END_QUOTE
[[file:../src/main.jl::350][main.jl:350]], [[aP7ivMRF][back to index]]
:END:

* More examples and Tips                                           :noexport:

*** Org-mode block in comment

For the moment these blocks are left unchanged. For the moment only EXAMPLE blocks work. For instance:
# CAVEAT: can not use RESULT because of NESTED EXAMPLE BLOCKS (org is lost!)
#+BEGIN_EXAMPLE
# Prints doc. This is the main function of the =J4Org= package.
#
# *Org-Mode Usage example:*
# #+BEGIN_EXAMPLE
# ,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
# documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
# print_org_doc(tag="API",header_level=0)
# ,#+END_SRC
# #+END_EXAMPLE
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::String="",
                       identifier::String="",
                       header_level::Int=0) = ...
#+END_EXAMPLE





This will generate this doc: 
#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("../src/");
print_org_doc(documented_items,identifier="print_org_doc",header_level=-1)
#+END_SRC

#+RESULTS:
:RESULTS:

 @@latex:\phantomsection@@  <<symMTtnLprint_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule")
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_SRC julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(documented_items,tag="API",header_level=0)
,#+END_SRC
#+END_SRC

*Arguments:*
- =tag=: tags to collect when generating the documentation
- =tag_to_ignore=: tags to ignore when generating the documentation
- =identifier=: generates documentation for this "identifier". Can be a function name, a structure name, etc…
- =link_prefix=: allows to add a prefix to extra link (#+tag L=extra_link). this is can be useful to avoid link name conflict when performing local doc extraction.
- =complete_link=: if true, try to fix link without target by adding extra items
- =case_sensitive=: case sensitive index.
- =boxingModule=: specifies the context in which "#!" code will be executed. See _initialize_boxing_module(...)_ for details.
#+END_QUOTE
[[file:../src/main.jl::350][main.jl:350]]
:END:

*** Julia code block in comment 
    :PROPERTIES:
    :ID:       f896399f-bd8f-4d68-b4ae-f67ed6a313ef
    :END:

You can define Julia code in comment:

#+BEGIN_SRC julia
,#+foo_doc
#
# You can redefine the foo function:
#
# #+BEGIN_SRC julia
# # julia code example
# foo(x::Float64) = 1
# #+END_SRC
#
foo(x::Int) = 2*x
#+END_SRC

#+RESULTS:

The generated code is:

#+RESULTS:
:RESULTS:


#+BEGIN_SRC julia
foo(x::Int)
#+END_SRC

#+RESULTS:

#+BEGIN_QUOTE
You can redefine the foo function:

#+BEGIN_SRC julia
# julia code example
foo(x::Float64) = 1
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:./code_examples/meaninglesscode.jl::1][meaninglesscode.jl:1]]
:END:

*Note:* maybe in the future Julia SRC blocks will be evaluated,
 however this functionality is not available for the moment.

*** Obsolete stuff

You can use 
#+BEGIN_EXAMPLE
- [ ] todo 
#+END_EXAMPLE
in a comment block 

for instance
#+BEGIN_EXAMPLE
,#+Obsolete
#
#  - [ ] remove me (to be replaced by find_tag)
#
function is_tag(tok::Tokenized,idx::Int)::Bool
#+END_EXAMPLE




* Unit tests

#+BEGIN_SRC julia :results output table :exports results
include("../test/runtests.jl")
#+END_SRC

#+RESULTS:
: Test Summary: | Pass  Total
: J4Org         |  126    126

* Code/Design tips                                                
** PDF export & phantomsection 

To be able to use links everywhere we use the
="@@latex:\\phantomsection@@"= tricks. See
[[https://tex.stackexchange.com/questions/44088/when-do-i-need-to-invoke-phantomsection][when-do-i-need-to-invoke-phantomsection]] for instance.

** HTML export with background

See https://github.com/JuliaEditorSupport/julia-emacs/issues/53

** Steps to add a new item 
We use =enum= as example
*** =tokenizer.jl= file
Add: =is_enum()= and =skip_enum_block()= functions
**** tests 
Add 
#+BEGIN_SRC julia :eval never :exports code 
import J4Org: is_enum

@testset "is_enum" begin
    t=tokenized("@enum Alpha A B")
    @test is_enum(t,1)
end;

#+END_SRC
*** =extract.jl= file
Add: =struct Extracted_Enum= and =extract_enum()= function.

Then complete =extract_code()= to take into account the extracted =Documented_Item=.
**** tests 
Create a basic file like: =test/code_example/enum.jl=
#+BEGIN_SRC 
,#+Tag L:target 
# This is an enum example [[target][]]
@enum Alpha A  B=1 C
#+END_SRC
Add 
#+BEGIN_SRC julia
import J4Org: extract_enum

@testset "enum" begin
    filename="$(dirname(@__FILE__))/code_examples/enum.jl"
    t=tokenized(readstring(filename))
    r = extract_enum(t,1)
    @test r!=nothing
    @test raw_string(r) == "@enum Alpha A  B=1 C"
    @test identifier(r) == "Alpha"
end;
#+END_SRC
*** =link.jl= file 

This is not mandatory, however if you want to magnify link to enum,
you can update the =create_link_readable_part()= function.
**** tests 
Link magnification is checked in [[id:b84e7269-ae02-4c64-b180-6b50d6f8aa89][=documented_item.jl=]]
*** =documented_item.jl=
    :PROPERTIES:
    :ID:       b84e7269-ae02-4c64-b180-6b50d6f8aa89
    :END:
Add the =is_documented_enum_type()= function.
**** tests 
Add 
#+BEGIN_SRC julia :eval never :exports code 
@testset "enum" begin
    filename="$(dirname(@__FILE__))/code_examples/enum.jl"
    t=tokenized(readstring(filename))
    r=find_tag(t,1)
    di=create_documented_item(t,tag_idx(r),filename=filename)
    @test org_string_comment(di,[di],[di],"","BoxingModule") == 
      "#+BEGIN_QUOTE\nThis is an enum example [[target][@enum Alpha]]\n#+END_QUOTE\n"
    @test org_string_code(di) == 
     "#+BEGIN_SRC julia :eval never :exports code\n@enum Alpha A  B=1 C\n#+END_SRC\n"
 end;
#+END_SRC

