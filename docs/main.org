#+SETUPFILE: ./Setup/setupFile.org
#+TITLE: J4Org Package
#+FILETAGS: Julia
#+PROPERTY: header-args:julia :session *JuliaDoc_session* :exports code :eval no-export
#+HTML_HEAD_EXTRA: <style type="text/css"> blockquote {background:#EEEEEE; padding: 3px 13px}    </style>
#+HTML_HEAD_EXTRA: <style type="text/css"> pre {background:#EEEEEE; padding: 3px 13px}    </style>

#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[]{
  bgcolor=bg,
  breaklines=true,
  breakanywhere=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

* Introduction

Defines a the *J4Org.jl* package, using [[https://github.com/KristofferC/Tokenize.jl/][Tokenize.jl]], to generate Julia
code documentation into Org-Mode document.

** Minimal requirements 

You need [[https://orgmode.org/][Org-Mode]] plus [[https://github.com/gjkerns/ob-julia/blob/master/ob-julia-doc.org][ob-julia.el]], which has [[http://stat.ethz.ch/ESS/index.php?Section=download][ESS]] as dependence, to be
installed.

** Minimal example

*** Emacs configuration

 A minimal =.emacs= file can be defined as follows:

#+BEGIN_SRC emacs-lisp :tangle yes :tangle minimal_example/init.el
(package-initialize)

(require 'ess-site)
;; if required
;; (setq  inferior-julia-program-name "/path/to/julia-release-basic")

(require 'org)
;; *replace me* with your own ob-julia.el file location 
(add-to-list 'load-path "~/GitLab/WorkingWithOrgMode/EmacsFiles")
;; babel configuration
(setq org-confirm-babel-evaluate nil)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((julia . t)))
#+END_SRC

*** A documented Julia =Foo= module

The documented module is as follows:

#+BEGIN_SRC julia :eval never :tangle yes :tangle minimal_example/Foo.jl
module Foo

export Point, foo
    
import Base: norm

#+Point L:Point_struct
# This is my Point structure
#
# *Example:*
#
# Creates a point $p$ of coordinates $(x=1,y=2)$.
#
# #+BEGIN_SRC julia :eval never :exports code
# p=Point(1,2)
# #+END_SRC
#
# You can add any valid Org mode directive. If you want to use
# in-documentation link, use [[norm_link_example][]]
#
struct Point
    x::Float64
    y::Float64
end

#+Point
# Creates Point at origin $(0,0)$ 
Point() = Point(0,0)

#+Point,Method L:norm_link_example
# A simple function that computes
# $$
# \sqrt{x^2+y^2}
# $$
#
# *Example:*
#!p=Point(1.0,2.0);
#!norm(p) 
#
# See: [[Point_struct][]]
#
norm(p::Point)::Float64 = sqrt(p.x*p.x+p.y*p.y)

#+Method,Internal
# An internal function
#
# For symbol that are not exported, do not forget the "Foo." prefix:
#!p=Point(1.0,2.0)
#!Foo.foo(2.0,p)
foo(r::Float64,p::Point) = Point(r*p.x,r*p.y)

end 
#+END_SRC


*** Minimal org mode document

This is the =foo.org= file.

#+BEGIN_SRC org :tangle :tangle minimal_example/foo.org 
,#+PROPERTY: header-args:julia :session *my_session* :exports code :eval no-export
,#+OPTIONS: ^:{}
,#+TITLE: Minimal example

# usually this part is required, however for this miminal_example
# we need to specify where to find the "Foo" module.
#
,#+BEGIN_SRC julia :results output none :eval no-export :exports none
push!(LOAD_PATH,pwd())
,#+END_SRC

,#+BEGIN_SRC julia :results output none :eval no-export :exports none
using J4Org
# notifies J4Org that it needs "using Foo" to run Julia code snippets
# in the documented code (those tagged as "#!")
initialize_boxing_module(usedModules=["Foo"])
# loads and tokenizes source code files, here only one file.
documented_items=create_documented_item_array("Foo.jl")
,#+END_SRC

,* Example

Prints all documented items, except those tagged with "Internal" 
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
print_org_doc(documented_items,tag_to_ignore=["Internal"],header_level=0)
,#+END_SRC
#+END_SRC

*** Generating the doc


* Usage examples

Let's use *J4Org.jl* for self-documentation, =API= functions

#+BEGIN_SRC julia :results output drawer :eval no-export :exports both
using Revise
using J4Org
initialize_boxing_module(usedModules=["J4Org"])
#+END_SRC


#+BEGIN_SRC julia :results output drawer :eval no-export :exports both
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="API",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:

<<RYTYsq3U>> *Index:* *[c]* [[ooSrQLog][create_documented_item_array]], [[JaWM5HYc][create_documented_item_array_dir]] *[e]* [[3XpvUT09][export]] *[i]* [[10ZtPcbh][initialize_boxing_module]] *[p]* [[1eTxJVN8][print_org_doc]] 
- @@latex:\phantomsection@@ *=create_documented_item_array=*  <<ooSrQLog>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename::String)::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a file from its *filename* and returns an array of documented items.
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::89][documented_item.jl:89]], [[RYTYsq3U][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename_list::Array{String,1})::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a files and returns an array of documented items.

*Usage example:* (attention to ; separator)
#+BEGIN_SRC julia
create_documented_item_array([file1;file2;...])
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::128][documented_item.jl:128]], [[RYTYsq3U][back to index]]
- @@latex:\phantomsection@@ *=create_documented_item_array_dir=*  <<JaWM5HYc>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array_dir(dirname::String)
#+END_SRC
#+BEGIN_QUOTE
Reads all jl files in a directory
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::147][documented_item.jl:147]], [[RYTYsq3U][back to index]]
- @@latex:\phantomsection@@ *=export=*  <<3XpvUT09>>
#+BEGIN_SRC julia :eval never :exports code
export create_documented_item_array_dir, print_org_doc
#+END_SRC
#+BEGIN_QUOTE
Exported symbols
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/J4Org.jl::3][J4Org.jl:3]], [[RYTYsq3U][back to index]]
- @@latex:\phantomsection@@ *=initialize_boxing_module=*  <<10ZtPcbh>>
#+BEGIN_SRC julia :eval never :exports code
function initialize_boxing_module(;boxingModule::String="BoxingModule",usedModules::Vector{String}=String[],force::Bool=false)::Void
#+END_SRC
#+BEGIN_QUOTE
Initialize a boxing module. This module is used to run Julia comment
code snippet (tagged by #!)
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/evaluate.jl::17][evaluate.jl:17]], [[RYTYsq3U][back to index]]
- @@latex:\phantomsection@@ *=print_org_doc=*  <<1eTxJVN8>> <<30XhCfBdprint_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule")
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_EXAMPLE
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(tag="API",header_level=0)
,#+END_SRC
#+END_EXAMPLE

*Arguments:*
- *link_prefix:* allows to add a prefix to extra link (#+tags    L:extra_link).
                 this is can be useful to avoid link name conflict when performing local doc extraction.
- *complete_link:* if true, try to fix link without target by adding extra items
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/main.jl::346][main.jl:346]], [[RYTYsq3U][back to index]]
:END:


** Tips

*** Org-mode block in comment

For the moment these blocks are left unchanged. For the moment only EXAMPLE blocks work. For instance:
# CAVEAT: can not use RESULT because of NESTED EXAMPLE BLOCKS (org is lost!)
#+BEGIN_EXAMPLE
# Prints doc. This is the main function of the =J4Org= package.
#
# *Org-Mode Usage example:*
# #+BEGIN_EXAMPLE
# ,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
# documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
# print_org_doc(tag="API",header_level=0)
# ,#+END_SRC
# #+END_EXAMPLE
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::String="",
                       identifier::String="",
                       header_level::Int=0) = ...
#+END_EXAMPLE





This will generate this doc: 
#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,identifier="print_org_doc",header_level=-1)
#+END_SRC

#+RESULTS:
:RESULTS:

 @@latex:\phantomsection@@  <<fuGcZYAkprint_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule")
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_EXAMPLE
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(tag="API",header_level=0)
,#+END_SRC
#+END_EXAMPLE

*Arguments:*
- *link_prefix:* allows to add a prefix to extra link (#+tags    L:extra_link).
                 this is can be useful to avoid link name conflict when performing local doc extraction.
- *complete_link:* if true, try to fix link without target by adding extra items
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/main.jl::346][main.jl:346]]
:END:

*** Julia code block in comment 
    :PROPERTIES:
    :ID:       f896399f-bd8f-4d68-b4ae-f67ed6a313ef
    :END:

You can define Julia code in comment:

#+INCLUDE: "./code_examples/meaninglesscode.jl" src julia

The generated code is:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items_docs=create_documented_item_array_dir("./code_examples/");
print_org_doc(documented_items_docs,tag="foo_doc",header_level=-1)
#+END_SRC

#+RESULTS:
:RESULTS:


#+BEGIN_SRC julia :eval never :exports code
foo(x::Int)
#+END_SRC
#+BEGIN_QUOTE
You can redefine the foo function:

#+BEGIN_SRC julia
# julia code example
foo(x::Float64) = 1
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:./code_examples/meaninglesscode.jl::1][meaninglesscode.jl:1]]
:END:

*Note:* maybe in the future Julia SRC blocks will be evaluated,
 however this functionality is not available for the moment.

*** Obsolete stuff

You can use 
#+BEGIN_EXAMPLE
- [ ] todo 
#+END_EXAMPLE
in a comment block 

for instance
#+BEGIN_EXAMPLE
,#+Obsolete
#
#  - [ ] remove me (to be replaced by find_tag)
#
function is_tag(tok::Tokenized,idx::Int)::Bool
#+END_EXAMPLE



* Documentation

** API

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="API",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:

<<zj5fdUXG>> *Index:* *[c]* [[UHugJ9p3][create_documented_item_array]], [[j0lCHG1g][create_documented_item_array_dir]] *[e]* [[YKcg5vMp][export]] *[i]* [[WLA9eepy][initialize_boxing_module]] *[p]* [[pR2RkWba][print_org_doc]] 
- @@latex:\phantomsection@@ *=create_documented_item_array=*  <<UHugJ9p3>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename::String)::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a file from its *filename* and returns an array of documented items.
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::89][documented_item.jl:89]], [[zj5fdUXG][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename_list::Array{String,1})::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a files and returns an array of documented items.

*Usage example:* (attention to ; separator)
#+BEGIN_SRC julia
create_documented_item_array([file1;file2;...])
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::128][documented_item.jl:128]], [[zj5fdUXG][back to index]]
- @@latex:\phantomsection@@ *=create_documented_item_array_dir=*  <<j0lCHG1g>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array_dir(dirname::String)
#+END_SRC
#+BEGIN_QUOTE
Reads all jl files in a directory
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::147][documented_item.jl:147]], [[zj5fdUXG][back to index]]
- @@latex:\phantomsection@@ *=export=*  <<YKcg5vMp>>
#+BEGIN_SRC julia :eval never :exports code
export create_documented_item_array_dir, print_org_doc
#+END_SRC
#+BEGIN_QUOTE
Exported symbols
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/J4Org.jl::3][J4Org.jl:3]], [[zj5fdUXG][back to index]]
- @@latex:\phantomsection@@ *=initialize_boxing_module=*  <<WLA9eepy>>
#+BEGIN_SRC julia :eval never :exports code
function initialize_boxing_module(;boxingModule::String="BoxingModule",usedModules::Vector{String}=String[],force::Bool=false)::Void
#+END_SRC
#+BEGIN_QUOTE
Initialize a boxing module. This module is used to run Julia comment
code snippet (tagged by #!)
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/evaluate.jl::17][evaluate.jl:17]], [[zj5fdUXG][back to index]]
- @@latex:\phantomsection@@ *=print_org_doc=*  <<pR2RkWba>> <<WlkWcamvprint_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule")
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_EXAMPLE
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(tag="API",header_level=0)
,#+END_SRC
#+END_EXAMPLE

*Arguments:*
- *link_prefix:* allows to add a prefix to extra link (#+tags    L:extra_link).
                 this is can be useful to avoid link name conflict when performing local doc extraction.
- *complete_link:* if true, try to fix link without target by adding extra items
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/main.jl::346][main.jl:346]], [[zj5fdUXG][back to index]]
:END:


* Internal documention
** Error management

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="Error",tag_to_ignore=["Documented_Item"],header_level=0,complete_link=false)
#+END_SRC

#+RESULTS:
:RESULTS:

<<7GbdEZda>> *Index:* *[c]* [[qr4XOP7V][create_file_org_link]] *[w]* [[ZQcZhdzw][warning_message]] 
- @@latex:\phantomsection@@ *=create_file_org_link=*  <<qr4XOP7V>>
#+BEGIN_SRC julia :eval never :exports code
function create_file_org_link(filename::String,line::Int=0)::String
#+END_SRC
#+BEGIN_QUOTE
Generate a org compatible link to file
*Examples:*
#+BEGIN_SRC julia
J4Org.create_file_org_link("/path/file.txt")
J4Org.create_file_org_link("/path/file.txt",10)
#+END_SRC

#+RESULTS:
| [ |
| [ |
| f |
| i |
| l |
| e |
| : |
| p |
| a |
| t |
| h |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| : |
| 1 |
| 0 |
| ] |
| [ |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| 1 |
| 0 |
| ] |
| ] |

#+BEGIN_SRC julia
"[[file:/path/file.txt][file.txt]]"
"[[file:/path/file.txt::10][file.txt:10]]"
#+END_SRC

#+RESULTS:
| [ |
| [ |
| f |
| i |
| l |
| e |
| : |
| p |
| a |
| t |
| h |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| : |
| 1 |
| 0 |
| ] |
| [ |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| 1 |
| 0 |
| ] |
| ] |

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/J4Org.jl::20][J4Org.jl:20]], [[7GbdEZda][back to index]]
- @@latex:\phantomsection@@ *=warning_message=*  <<ZQcZhdzw>>
#+BEGIN_SRC julia :eval never :exports code
function warning_message(message::String)::Void
#+END_SRC
#+BEGIN_QUOTE
You must use this function to print error message,
It generates a message of the form
#+BEGIN_EXAMPLE 
# =WARNING:= message
#+END_EXAMPLE
which is an Org mode *comment*, hence it does not affect function output.
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/J4Org.jl::8][J4Org.jl:8]], [[7GbdEZda][back to index]]
:END:



#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="Links",header_level=0,complete_link=true)
#+END_SRC

#+RESULTS:
:RESULTS:

<<kEbAUZsr>> *Index:* *[D]* [[zOYEE9ys][Documented_Item]] *[c]* [[hIpBl7YK][clean_extracted_links]], [[YVhEbhZA][create_file_org_link]] *[d]* [[s0UbgNlj][doc_link_substituion]] *[e]* [[oujzG9jy][extract_links]] *[g]* [[XOTqfgHw][get_items_with_link_target]] 
- @@latex:\phantomsection@@ *=Documented_Item=*  <<zOYEE9ys>> <<XXXfNYpUDocumented_Item>>
#+BEGIN_SRC julia :eval never :exports code
struct Documented_Item
#+END_SRC
#+BEGIN_QUOTE
A *central* structure containing documented item
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::1][documented_item.jl:1]], [[kEbAUZsr][back to index]]
- @@latex:\phantomsection@@ *=clean_extracted_links=*  <<hIpBl7YK>>
#+BEGIN_SRC julia :eval never :exports code
function clean_extracted_links(toClean::Vector{Tuple{String,String}})::Vector{Tuple{String,String}}
#+END_SRC
#+BEGIN_QUOTE
This function clean extracted links by removing duplicates

See: [[XXXfNYpUextract_links_string][extract_links(...)]]
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/links.jl::60][links.jl:60]], [[kEbAUZsr][back to index]]
- @@latex:\phantomsection@@ *=create_file_org_link=*  <<YVhEbhZA>>
#+BEGIN_SRC julia :eval never :exports code
function create_file_org_link(di::Documented_Item)::String
#+END_SRC
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::49][documented_item.jl:49]], [[kEbAUZsr][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function create_file_org_link(filename::String,line::Int=0)::String
#+END_SRC
#+BEGIN_QUOTE
Generate a org compatible link to file
*Examples:*
#+BEGIN_SRC julia
J4Org.create_file_org_link("/path/file.txt")
J4Org.create_file_org_link("/path/file.txt",10)
#+END_SRC

#+RESULTS:
| [ |
| [ |
| f |
| i |
| l |
| e |
| : |
| p |
| a |
| t |
| h |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| : |
| 1 |
| 0 |
| ] |
| [ |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| 1 |
| 0 |
| ] |
| ] |

#+BEGIN_SRC julia
"[[file:/path/file.txt][file.txt]]"
"[[file:/path/file.txt::10][file.txt:10]]"
#+END_SRC

#+RESULTS:
| [ |
| [ |
| f |
| i |
| l |
| e |
| : |
| p |
| a |
| t |
| h |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| : |
| 1 |
| 0 |
| ] |
| [ |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| 1 |
| 0 |
| ] |
| ] |

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/J4Org.jl::20][J4Org.jl:20]], [[kEbAUZsr][back to index]]
- @@latex:\phantomsection@@ *=doc_link_substituion=*  <<s0UbgNlj>> <<XXXfNYpUdoc_link_substituion>>
#+BEGIN_SRC julia :eval never :exports code
function doc_link_substituion(doc::String,di_array::Array{Documented_Item,1},link_prefix::String)::String
#+END_SRC
#+BEGIN_QUOTE
From doc string performs links substitution

- check if there are links in the doc, eventually return unmodified doc string 
- for each link check if it exists in di_array
  - yes, replace ​[​[link_target][]] by ​[​[link_prefix_link_target][identifier]] to create a valid OrgMode link.
  - no,  replace ​[​[link_target][]] by _link_target_ to create an inactive link 

*Note:* in order to do not interfere with org mode link we only process "links" of the form "[[something][]]"
        see https://orgmode.org/manual/Link-format.html

*Note:* to be able to write a "unactive" link, use C-x 8 RET 200b
        (see: https://emacs.stackexchange.com/a/16702)
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/links.jl::89][links.jl:89]], [[kEbAUZsr][back to index]]
- @@latex:\phantomsection@@ *=extract_links=*  <<oujzG9jy>> <<XXXfNYpUextract_links_string>>
#+BEGIN_SRC julia :eval never :exports code
function extract_links(input::String)::Vector{Tuple{String,String}}
#+END_SRC
#+BEGIN_QUOTE
This function returns the list of links found in the string. It
returns nothing if no link is found

#+BEGIN_SRC julia
s="# some text [[some_target][]] another one [[link_target][link_name]]\n and a last one [[a4][b1]]"
J4Org.extract_links(s)
#+END_SRC

#+RESULTS:
: some_target

#+BEGIN_EXAMPLE
1-element Array{Tuple{String,String},1}:
 ("some_target", "")         
#+END_EXAMPLE

*Caveat:* only use links of the forme ​"[​[something][]]", which are not
          valid Org mode links, see [[XXXfNYpUdoc_link_substituion][doc_link_substituion(...)]]

*Test link:* [[XXXfNYpUdoc_link_substituion][doc_link_substituion(...)]]
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/links.jl::2][links.jl:2]], [[kEbAUZsr][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function extract_links(di_array::Array{Documented_Item,1})::Vector{Tuple{String,String}}
#+END_SRC
#+BEGIN_QUOTE
This function is like [[XXXfNYpUextract_links_string][extract_links(...)]], except that is
process an array of [[XXXfNYpUDocumented_Item][struct Documented_Item]]
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/links.jl::45][links.jl:45]], [[kEbAUZsr][back to index]]
- @@latex:\phantomsection@@ *=get_items_with_link_target=*  <<XOTqfgHw>>
#+BEGIN_SRC julia :eval never :exports code
function get_items_with_link_target(link_target::String,di_array::Array{Documented_Item,1})::Vector{Int}
#+END_SRC
#+BEGIN_QUOTE
Returns the indices of [[XXXfNYpUDocumented_Item][struct Documented_Item]] containing the
link_target (have a tag line with L:link_target)

*Note:* a normal situation is to have zero or one indices. Several
indices means that we do not have a unique target.
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/links.jl::70][links.jl:70]], [[kEbAUZsr][back to index]]
:END:

** Find Tag

The role of this group is to scan tokenized code to find tags.

#+BEGIN_EXAMPLE
#+Tags... L:extra_link
#+END_EXAMPLE

Then extracts information like =Tags= list and =extra_link= name.

 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="FindTag",header_level=0,complete_link=false)
 #+END_SRC

 #+RESULTS:
 :RESULTS:

 <<ZGCtoXS4>> *Index:* *[E]* [[1udfKYxi][Extract_Tag_Result]] *[e]* [[p8K0b8LG][extract_tag]] *[f]* [[sNA1a7d3][find_tag]] *[l]* [[EbhAVBW0][line]], [[8aNJT27A][link]] *[s]* [[pk7NE82N][skip]] *[t]* [[PBrDgS9n][tag_idx]], [[xAFyfZPg][tags]] 
 - @@latex:\phantomsection@@ *=Extract_Tag_Result=*  <<1udfKYxi>>
 #+BEGIN_SRC julia :eval never :exports code
 struct Extract_Tag_Result <: Extracted_Item_Base
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::2][find_tag.jl:2]], [[ZGCtoXS4][back to index]]
 - @@latex:\phantomsection@@ *=extract_tag=*  <<p8K0b8LG>> <<CvN1Z4itextract_tag_link>>
 #+BEGIN_SRC julia :eval never :exports code
 function extract_tag(tok::Tokenized,idx::Int)::Union{Void,Extract_Tag_Result}
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::27][find_tag.jl:27]], [[ZGCtoXS4][back to index]]
 - @@latex:\phantomsection@@ *=find_tag=*  <<sNA1a7d3>> <<CvN1Z4itfind_tag_master>>
 #+BEGIN_SRC julia :eval never :exports code
 function find_tag(tok::Tokenized,idx::Int,predicate::Function)::Union{Void,Extract_Tag_Result}
 #+END_SRC
 #+BEGIN_QUOTE
 If some tags are found use the
 #+BEGIN_SRC julia
 predicate(r::Extract_Tag_Result)::Bool
 #+END_SRC

 #+RESULTS:

 to accept (or not) the tags

 *Returns:*
 - =(idx,Extract_Tag_Result)=: where =idx= is the position of the discovered tag
 - =(length(tok)+1,nothing)=: if no tag found
 #+END_QUOTE
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::76][find_tag.jl:76]], [[ZGCtoXS4][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 function find_tag(tok::Tokenized,idx::Int)::Union{Void,Extract_Tag_Result}
 #+END_SRC
 #+BEGIN_QUOTE
 Convenience function that uses [[CvN1Z4itfind_tag_master][find_tag(...)]] with =x->true=
 predicate. It accepts all tags
 #+END_QUOTE
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::104][find_tag.jl:104]], [[ZGCtoXS4][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 function find_tag(tok::Tokenized,idx::Int,tag::String)::Union{Void,Extract_Tag_Result}
 #+END_SRC
 #+BEGIN_QUOTE
 Convenience function that uses  find_tag_master find_tag  with a
 predicate that checks for *Tag* existence.
 #+END_QUOTE
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::112][find_tag.jl:112]], [[ZGCtoXS4][back to index]]
 - @@latex:\phantomsection@@ *=line=*  <<EbhAVBW0>>
 #+BEGIN_SRC julia :eval never :exports code
 line(o::Extract_Tag_Result)::Int
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::22][find_tag.jl:22]], [[ZGCtoXS4][back to index]]
 - @@latex:\phantomsection@@ *=link=*  <<8aNJT27A>>
 #+BEGIN_SRC julia :eval never :exports code
 link(o::Extract_Tag_Result)::String
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::19][find_tag.jl:19]], [[ZGCtoXS4][back to index]]
 - @@latex:\phantomsection@@ *=skip=*  <<pk7NE82N>>
 #+BEGIN_SRC julia :eval never :exports code
 skip(o::Extract_Tag_Result)::Int
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::13][find_tag.jl:13]], [[ZGCtoXS4][back to index]]
 - @@latex:\phantomsection@@ *=tag_idx=*  <<PBrDgS9n>>
 #+BEGIN_SRC julia :eval never :exports code
 tag_idx(o::Extract_Tag_Result)::Int
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::10][find_tag.jl:10]], [[ZGCtoXS4][back to index]]
 - @@latex:\phantomsection@@ *=tags=*  <<xAFyfZPg>>
 #+BEGIN_SRC julia :eval never :exports code
 tags(o::Extract_Tag_Result)::Array{String,1}
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::16][find_tag.jl:16]], [[ZGCtoXS4][back to index]]
 :END:

* TODO list [0/2]
** TODO development [5/10]
- [ ] add a function to show link and targets & detect useless link_target
- [ ] search for "export" keyword to annotate documented item 
- [ ] even if complete_link = false, search for target in order to do pretty print (information like struct etc...)
- [X] use extracted tag in DocumentedItem
- [X] allows tag list "#+tag1, tag2"
- [X] add prefix to extra link: <<link>> -> <<prefix_link>>
- [X] finish parsing and code cleaning 
- [ ] add an option to extract code body
- [ ] :RESULT: bug
- [X] fix ugly PDF link 
- [ ] detect constructor
- [X] for the index, lexico sort: l = L (sort not sensitive to capital)
- [ ] allows an alternative syntax (maybe not a good idea?)
#+BEGIN_SRC julia :eval never :exports code 
#<Tokenizer,Internal
# common doc
is_structure(tok::Tokenized,idx::Int)::Bool = (exactkind(tok[idx])==Tokenize.Tokens.STRUCT)
is_function(tok::Tokenized,idx::Int)::Bool = (exactkind(tok[idx])==Tokenize.Tokens.FUNCTION)
is_comment(tok::Tokenized,idx::Int)::Bool = (kind(tok[idx])==Tokenize.Tokens.COMMENT)
is_whitespace(tok::Tokenized,idx::Int)::Bool = (kind(tok[idx])==Tokenize.Tokens.WHITESPACE)
is_identifier(tok::Tokenized,idx::Int)::Bool = (exactkind(tok[idx])==Tokenize.Tokens.IDENTIFIER)
#>
#+END_SRC

** TODO code [0/0]

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="TODO",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:

<<xxEwCRi3>> *Index:* *[E]* [[upllexho][Extracted_Item_Base]] *[w]* [[G5g0gxVC][with_hash_evaluate]] 
- @@latex:\phantomsection@@ *=Extracted_Item_Base=*  <<upllexho>> <<sPb5NRq5Extracted_Item_Base>>
#+BEGIN_SRC julia :eval never :exports code
abstract type Extracted_Item_Base 
#+END_SRC
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::3][extract.jl:3]], [[xxEwCRi3][back to index]]
- @@latex:\phantomsection@@ *=with_hash_evaluate=*  <<G5g0gxVC>>
#+BEGIN_SRC julia :eval never :exports code
function with_hash_evaluate(comment::String,
                            boxingModule::String)::String
#+END_SRC
#+BEGIN_QUOTE
Parse and execute a Julia code snippet

The format is raw comment
#+BEGIN_EXAMPLE
# some text
#!5+6
#!rand(5)
# some text 
#+END_EXAMPLE

Example:
#+BEGIN_SRC julia
5+6
rand(5)
#+END_SRC

#+RESULTS:
| 0.37336130056919803 |
|  0.5336651179202612 |
|  0.8183375565134803 |
|  0.4596756705183185 |
|  0.6012430089831795 |

#+BEGIN_SRC julia
11
5-element Array{Float64,1}:
 0.618715
 0.303327
 0.29002 
 0.140657
 0.107546
#+END_SRC

#+RESULTS:
: 0.107546

- [ ] TODO skip output for code ending with ";"
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/evaluate.jl::48][evaluate.jl:48]], [[xxEwCRi3][back to index]]
:END:

* Unit tests

#+BEGIN_SRC julia :results output table :exports results
include("../test/runtests.jl")
#+END_SRC

#+RESULTS:
: # =WARNING:= Link target ("faa", "") not found
: Test Summary: | Pass  Total
: J4Org         |   96     96



* Designs tips

** PDF export & phantomsection 

To be able to use links everywhere we use the
="@@latex:\\phantomsection@@"= tricks. See
[[https://tex.stackexchange.com/questions/44088/when-do-i-need-to-invoke-phantomsection][when-do-i-need-to-invoke-phantomsection]] for instance.

** HTML export with background

See https://github.com/JuliaEditorSupport/julia-emacs/issues/53

** Warning/Error messages

The trick is to generate Org mode comments.

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="Tokenizer",header_level=0,complete_link=true)
#+END_SRC

#+RESULTS:
:RESULTS:

<<qttA4xGs>> *Index:* *[E]* [[upqudCMd][Extracted_Function]], [[ohlzDlSN][Extracted_Item_Base]] *[e]* [[GnYv9dv4][extract_abstract]], [[HtfpKWii][extract_export]], [[Vu7W6eF0][extract_function]], [[qjG2Tni1][extract_struct]] *[s]* [[OF9S6qZP][skip_abstract_block]], [[TMik1awd][skip_comma_separated_identifiers]], [[ENs3PquH][skip_comment]], [[kPaVDqHV][skip_declaration_block]], [[PCQNXVQi][skip_function_call_block]], [[LnT8u8If][skip_identifier]], [[hrOQf2Zi][skip_issubtype_block]], [[nbJpmv0R][skip_struct_block]], [[U4f8kI7P][skip_uninformative]], [[wCMx63vo][skip_where_block]], [[wDBZFRyN][skip_whitespace]], [[GSioLgBZ][skip_whitespace_strict]] *[t]* [[gBpI3pMO][tokenized]] 
- @@latex:\phantomsection@@ *=Extracted_Function=*  <<upqudCMd>>
#+BEGIN_SRC julia :eval never :exports code
struct Extracted_Function <: Extracted_Item_Base
#+END_SRC
#+BEGIN_QUOTE
A structure to store extracted function.

See: [[Zjq8SftWExtracted_Item_Base][abstract Extracted_Item_Base]], [[Zjq8SftWextract_function][extract_function(...)]]
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::75][extract.jl:75]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=Extracted_Item_Base=*  <<ohlzDlSN>> <<Zjq8SftWExtracted_Item_Base>>
#+BEGIN_SRC julia :eval never :exports code
abstract type Extracted_Item_Base 
#+END_SRC
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::3][extract.jl:3]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=extract_abstract=*  <<GnYv9dv4>>
#+BEGIN_SRC julia :eval never :exports code
function extract_abstract(tok::Tokenized,idx::Int)::Union{Void,Extracted_Abstract}
#+END_SRC
#+BEGIN_QUOTE
Extract abstract type
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::185][extract.jl:185]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=extract_export=*  <<HtfpKWii>>
#+BEGIN_SRC julia :eval never :exports code
function extract_export(tok::Tokenized,idx::Int)::Union{Void,Extracted_Export}
#+END_SRC
#+BEGIN_QUOTE
Extract export
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::157][extract.jl:157]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=extract_function=*  <<Vu7W6eF0>> <<Zjq8SftWextract_function>>
#+BEGIN_SRC julia :eval never :exports code
function extract_function(tok::Tokenized,idx::Int)::Union{Void,Extracted_Function}
#+END_SRC
#+BEGIN_QUOTE
Extract function
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::87][extract.jl:87]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=extract_struct=*  <<qjG2Tni1>>
#+BEGIN_SRC julia :eval never :exports code
function extract_struct(tok::Tokenized,idx::Int)::Union{Void,Extracted_Struct}
#+END_SRC
#+BEGIN_QUOTE
Extract struct
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::131][extract.jl:131]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_abstract_block=*  <<OF9S6qZP>>
#+BEGIN_SRC julia :eval never :exports code
function skip_abstract_block(tok::Tokenized,idx::Int;
                             identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & abstract type block
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::385][tokenizer.jl:385]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_comma_separated_identifiers=*  <<TMik1awd>>
#+BEGIN_SRC julia :eval never :exports code
function skip_comma_separated_identifiers(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a comma separated sequence of identifiers A,A.B.C,A.B{...}
Does not move is comma separeted identifier not found
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::231][tokenizer.jl:231]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_comment=*  <<ENs3PquH>>
#+BEGIN_SRC julia :eval never :exports code
function skip_comment(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip comment
-> replaced by skip uninformative
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::41][tokenizer.jl:41]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_declaration_block=*  <<kPaVDqHV>>
#+BEGIN_SRC julia :eval never :exports code
function skip_declaration_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a declaration block ::identifier{...}
Does not move in case of identification failure
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::282][tokenizer.jl:282]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_function_call_block=*  <<PCQNXVQi>>
#+BEGIN_SRC julia :eval never :exports code
function skip_function_call_block(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a function call block identifier{...}(....)
Does not move in case of identification failure
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::301][tokenizer.jl:301]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_identifier=*  <<LnT8u8If>>
#+BEGIN_SRC julia :eval never :exports code
function skip_identifier(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & identifier A or A.B.C or A.B{...}
Returns (name,idx) if prod
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::183][tokenizer.jl:183]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_issubtype_block=*  <<hrOQf2Zi>>
#+BEGIN_SRC julia :eval never :exports code
function skip_issubtype_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & issubtype indentifier
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::327][tokenizer.jl:327]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_struct_block=*  <<nbJpmv0R>>
#+BEGIN_SRC julia :eval never :exports code
function skip_struct_block(tok::Tokenized,idx::Int;
                          identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & structure block
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::349][tokenizer.jl:349]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_uninformative=*  <<U4f8kI7P>>
#+BEGIN_SRC julia :eval never :exports code
function skip_uninformative(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip whitespace 
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::51][tokenizer.jl:51]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_where_block=*  <<wCMx63vo>>
#+BEGIN_SRC julia :eval never :exports code
function skip_where_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a where block (where {...} or where A,B
Does not move is comma separeted identifier not found
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::258][tokenizer.jl:258]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_whitespace=*  <<wDBZFRyN>>
#+BEGIN_SRC julia :eval never :exports code
function skip_whitespace(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip comment + whitespace 
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::60][tokenizer.jl:60]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_whitespace_strict=*  <<GSioLgBZ>>
#+BEGIN_SRC julia :eval never :exports code
function skip_whitespace_strict(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip whitespace
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::121][tokenizer.jl:121]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=tokenized=*  <<gBpI3pMO>>
#+BEGIN_SRC julia :eval never :exports code
tokenized(s::String)
#+END_SRC
#+BEGIN_QUOTE
Defines a convenient method to tokenize a =String=
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::7][tokenizer.jl:7]], [[qttA4xGs][back to index]]
:END:




