#+SETUPFILE: ./Setup/setupFile.org
#+TITLE: J4Org Package
#+FILETAGS: Julia
#+PROPERTY: header-args:julia :session *JuliaDoc_session* :exports code :eval no-export
#+HTML_HEAD_EXTRA: <style type="text/css"> blockquote {background:#EEEEEE; padding: 3px 13px}    </style>
#+HTML_HEAD_EXTRA: <style type="text/css"> pre {background:#EEEEEE; padding: 3px 13px}    </style>

#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[]{
  bgcolor=bg,
  breaklines=true,
  breakanywhere=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

#+BEGIN_SRC julia :results output none :eval no-export :exports none
using Revise
using J4Org
initialize_boxing_module(boxingModule="J4OrgBoxing",usedModules=["J4Org"],force=true)
#+END_SRC

# Also use Foo as example 
#+BEGIN_SRC julia :results output none :eval no-export :exports none
push!(LOAD_PATH,pwd()*"/minimal_example/")
initialize_boxing_module(usedModules=["Foo"],force=true)
#+END_SRC

* Introduction

Defines a the *J4Org.jl* package, using [[https://github.com/KristofferC/Tokenize.jl/][Tokenize.jl]], to generate Julia
code documentation into Org-Mode document.

** Minimal requirements 

You need [[https://orgmode.org/][Org-Mode]] plus [[https://github.com/gjkerns/ob-julia/blob/master/ob-julia-doc.org][ob-julia.el]], which has [[http://stat.ethz.ch/ESS/index.php?Section=download][ESS]] as dependence, to be
installed.

** Getting started with a minimal example

The following is a minimal example you can reproduce to have a taste
of what this package do.

*** Emacs configuration

You first need a minimal =init.el= file to configure Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes :tangle minimal_example/init.el
(package-initialize)

(require 'ess-site)
;; if required
;; (setq  inferior-julia-program-name "/path/to/julia-release-basic")

(require 'org)
;; *replace me* with your own ob-julia.el file location 
(add-to-list 'load-path "~/GitLab/WorkingWithOrgMode/EmacsFiles")
;; babel configuration
(setq org-confirm-babel-evaluate nil)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((julia . t)))
#+END_SRC

*** A documented Julia =Foo= module

Then you need a documented module:

#+BEGIN_SRC julia :eval never :tangle yes :tangle minimal_example/Foo.jl
module Foo

export Point, foo
    
import Base: norm

#+Point L:Point_struct
# This is my Point structure
#
# *Example:*
#
# Creates a point $p$ of coordinates $(x=1,y=2)$.
#
# #+BEGIN_SRC julia :eval never :exports code
# p=Point(1,2)
# #+END_SRC
#
# You can add any valid Org mode directive. If you want to use
# in-documentation link, use [[norm_link_example][]]
#
struct Point
    x::Float64
    y::Float64
end

#+Point
# Creates Point at origin $(0,0)$ 
Point() = Point(0,0)

#+Point,Method L:norm_link_example
# A simple function that computes
# $$
# \sqrt{x^2+y^2}
# $$
#
# *Example:*
#!p=Point(1.0,2.0);
#!norm(p) 
#
# See: [[Point_struct][]]
#
norm(p::Point)::Float64 = sqrt(p.x*p.x+p.y*p.y)

#+Method,Internal
# An internal function
#
# For symbol that are not exported, do not forget the "Foo." prefix:
#!p=Point(1.0,2.0)
#!Foo.foo(2.0,p)
foo(r::Float64,p::Point) = Point(r*p.x,r*p.y)

end 
#+END_SRC

I wanted to reduce the documentation process as much as possible. The
template is very simple. Before each item you want to document add
these comment lines:

#+BEGIN_SRC julia :eval never :exports code 
#+Tag1,Tag2,... L:an_extra_link_if_required 
#
# Here you can put any Org mode text, for instance $sin(x)$
#
#!sin(5) # julia code to be executed
#
# [[internal_link][]]
struct A_Documented_Struct 
...
end 
#+END_SRC

- *#+Tag1,Tag2,...* is mandatory, "#+" is followed by a list of
  tags. Later when you want to extract doc you can do filtering
  according these tags.

- *L:an_extra_link_if_required* is *not* mandatory. It defines a
  reference if you want to create doc links. The previous statement
  defines a link *target* named =an_extra_link_if_required=.

- *[[internal_link][]]* creates a link to a previously defined
  *L:internal_link*.

- *!sin(5)* will execute Julia code and include the output in the
  doc. If you only want to include Julia code without executing it,
  simply use Org mode source block:
#+BEGIN_SRC julia :eval never :exports code 
# #+BEGIN_SRC julia :eval never :exports code
# sin(5)
# #+END_SRC
#+END_SRC

*** Minimal OrgMode document

This is the =foo.org= file.

#+BEGIN_SRC bash :tangle :tangle minimal_example/foo.org 
,#+PROPERTY: header-args:julia :session *my_session* :exports code :eval no-export
,#+OPTIONS: ^:{}
,#+TITLE: Getting Started with a minimal example

,#+BEGIN_SRC julia :results output none :eval no-export :exports none
push!(LOAD_PATH,pwd())
,#+END_SRC

,#+BEGIN_SRC julia :results output none :eval no-export :exports none
using J4Org # (ref:using_J4Org)
initialize_boxing_module(usedModules=["Foo"]) 
documented_items=create_documented_item_array("Foo.jl")
,#+END_SRC

,* Example

Prints all documented items, except those tagged with "Internal" 
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
print_org_doc(documented_items,tag_to_ignore=["Internal"],header_level=0)
,#+END_SRC
#+END_SRC


- *push!(LOAD_PATH,pwd())* tells Julia where it can find our local =Foo=
  module. This statement is only required if the documented module is
  in an unusual place.

- *using J4Org* uses this package

- *initialize_boxing_module(usedModules=["Foo"])* defines what are
  the module to use when executing Julia code extracted from the doc
  (the "#!" statements). Here we are documenting the =Foo= module,
  hence we must use it. Note that you can also use any number of extra
  modules for instance with =["Foo", "ExtraModule", ...]=. See
  [[API_initialize_boxing_module][initialize_boxing_module(...)]] for further details.

- *create_documented_item_array("Foo.jl")* creates the list of
  documented item from file "Foo.jl". You can use a list of files and
  a directory, see [[API_create_documented_item_array_filename][create_documented_item_array(...)]] for further details.

- *print_org_doc(documented_items,tag_to_ignore=["Internal"],header_level=0)*
  prints all documented items, except those tagged with "Internal",
  see [[API_print_org_doc_API][print_org_doc(...)]] for further details

*** Generating the doc

To check that it works you can start a fresh emacs with

#+BEGIN_SRC bash
emacs -q --load init.el foo.org &
#+END_SRC

then type:
- =C-c C-v b= + =RET= to execute all source code blocks
- =C-c C-e h o= to html-export the file 
- =C-c C-e l o= to pdf-export the file 

*** Improving exported document style

This was a minimal example, you can have a better look for the
exported documents by including css theme, etc. This is the approach
we used to generate *this* document (also see the pdf file).

* More examples 

We still use our =Foo= module to provide more example. The complete [[id:c9053a86-dea5-4bc2-a883-92a1bfde20ba][API]] is detailed after.

** 

* API
  :PROPERTIES:
  :ID:       c9053a86-dea5-4bc2-a883-92a1bfde20ba
  :END:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,boxingModule="J4OrgBoxing",tag="API",header_level=0,link_prefix="API_")
#+END_SRC

#+RESULTS:
:RESULTS:

<<d3217XDy>> *Index:* *[c]* [[SNYOswY6][create_documented_item_array]], [[rCVq4Nlo][create_documented_item_array_dir]] *[e]* [[pSWolP1t][export]] *[i]* [[an9Dajlq][initialize_boxing_module]] *[p]* [[LXxtaIvX][print_org_doc]] 
- @@latex:\phantomsection@@ *=create_documented_item_array=*  <<SNYOswY6>> <<API_create_documented_item_array_filename>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename::String)::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a file from its *filename* and returns an array of documented items.
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::89][documented_item.jl:89]], [[d3217XDy][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename_list::Array{String,1})::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a files and returns an array of documented items.

*Usage example:* (attention to ; separator)
#+BEGIN_SRC julia
create_documented_item_array([file1;file2;...])
#+END_SRC
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::128][documented_item.jl:128]], [[d3217XDy][back to index]]
- @@latex:\phantomsection@@ *=create_documented_item_array_dir=*  <<rCVq4Nlo>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array_dir(dirname::String)
#+END_SRC
#+BEGIN_QUOTE
Reads all jl files in a directory
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::147][documented_item.jl:147]], [[d3217XDy][back to index]]
- @@latex:\phantomsection@@ *=export=*  <<pSWolP1t>>
#+BEGIN_SRC julia :eval never :exports code
export create_documented_item_array_dir, print_org_doc
#+END_SRC
#+BEGIN_QUOTE
Exported symbols
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/J4Org.jl::3][J4Org.jl:3]], [[d3217XDy][back to index]]
- @@latex:\phantomsection@@ *=initialize_boxing_module=*  <<an9Dajlq>> <<API_initialize_boxing_module>>
#+BEGIN_SRC julia :eval never :exports code
function initialize_boxing_module(;boxingModule::String="BoxingModule",
                                  usedModules::Vector{String}=String[],
                                  force::Bool=false)::Void
#+END_SRC
#+BEGIN_QUOTE
Initialize a boxing module. This module is used to run Julia comment
code snippet (tagged by #!)
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/evaluate.jl::17][evaluate.jl:17]], [[d3217XDy][back to index]]
- @@latex:\phantomsection@@ *=print_org_doc=*  <<LXxtaIvX>> <<API_print_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule")
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_EXAMPLE
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(tag="API",header_level=0)
,#+END_SRC
#+END_EXAMPLE

*Arguments:*
- *link_prefix:* allows to add a prefix to extra link (#+tags    L:extra_link).
                 this is can be useful to avoid link name conflict when performing local doc extraction.
- *complete_link:* if true, try to fix link without target by adding extra items
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/main.jl::346][main.jl:346]], [[d3217XDy][back to index]]
:END:





* More examples and Tips

*** Org-mode block in comment

For the moment these blocks are left unchanged. For the moment only EXAMPLE blocks work. For instance:
# CAVEAT: can not use RESULT because of NESTED EXAMPLE BLOCKS (org is lost!)
#+BEGIN_EXAMPLE
# Prints doc. This is the main function of the =J4Org= package.
#
# *Org-Mode Usage example:*
# #+BEGIN_EXAMPLE
# ,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
# documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
# print_org_doc(tag="API",header_level=0)
# ,#+END_SRC
# #+END_EXAMPLE
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::String="",
                       identifier::String="",
                       header_level::Int=0) = ...
#+END_EXAMPLE





This will generate this doc: 
#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,identifier="print_org_doc",header_level=-1)
#+END_SRC

#+RESULTS:
:RESULTS:

 @@latex:\phantomsection@@  <<fuGcZYAkprint_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule")
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_EXAMPLE
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(tag="API",header_level=0)
,#+END_SRC
#+END_EXAMPLE

*Arguments:*
- *link_prefix:* allows to add a prefix to extra link (#+tags    L:extra_link).
                 this is can be useful to avoid link name conflict when performing local doc extraction.
- *complete_link:* if true, try to fix link without target by adding extra items
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/main.jl::346][main.jl:346]]
:END:

*** Julia code block in comment 
    :PROPERTIES:
    :ID:       f896399f-bd8f-4d68-b4ae-f67ed6a313ef
    :END:

You can define Julia code in comment:

#+INCLUDE: "./code_examples/meaninglesscode.jl" src julia

The generated code is:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items_docs=create_documented_item_array_dir("./code_examples/");
print_org_doc(documented_items_docs,tag="foo_doc",header_level=-1)
#+END_SRC

#+RESULTS:
:RESULTS:


#+BEGIN_SRC julia :eval never :exports code
foo(x::Int)
#+END_SRC
#+BEGIN_QUOTE
You can redefine the foo function:

#+BEGIN_SRC julia
# julia code example
foo(x::Float64) = 1
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:./code_examples/meaninglesscode.jl::1][meaninglesscode.jl:1]]
:END:

*Note:* maybe in the future Julia SRC blocks will be evaluated,
 however this functionality is not available for the moment.

*** Obsolete stuff

You can use 
#+BEGIN_EXAMPLE
- [ ] todo 
#+END_EXAMPLE
in a comment block 

for instance
#+BEGIN_EXAMPLE
,#+Obsolete
#
#  - [ ] remove me (to be replaced by find_tag)
#
function is_tag(tok::Tokenized,idx::Int)::Bool
#+END_EXAMPLE





* TODO list [0/2]
** TODO development [5/10]
- [ ] add a function to show link and targets & detect useless link_target
- [ ] search for "export" keyword to annotate documented item 
- [ ] even if complete_link = false, search for target in order to do pretty print (information like struct etc...)
- [X] use extracted tag in DocumentedItem
- [X] allows tag list "#+tag1, tag2"
- [X] add prefix to extra link: <<link>> -> <<prefix_link>>
- [X] finish parsing and code cleaning 
- [ ] add an option to extract code body
- [ ] :RESULT: bug
- [X] fix ugly PDF link 
- [ ] detect constructor
- [X] for the index, lexico sort: l = L (sort not sensitive to capital)
- [ ] allows an alternative syntax (maybe not a good idea?)
#+BEGIN_SRC julia :eval never :exports code 
#<Tokenizer,Internal
# common doc
is_structure(tok::Tokenized,idx::Int)::Bool = (exactkind(tok[idx])==Tokenize.Tokens.STRUCT)
is_function(tok::Tokenized,idx::Int)::Bool = (exactkind(tok[idx])==Tokenize.Tokens.FUNCTION)
is_comment(tok::Tokenized,idx::Int)::Bool = (kind(tok[idx])==Tokenize.Tokens.COMMENT)
is_whitespace(tok::Tokenized,idx::Int)::Bool = (kind(tok[idx])==Tokenize.Tokens.WHITESPACE)
is_identifier(tok::Tokenized,idx::Int)::Bool = (exactkind(tok[idx])==Tokenize.Tokens.IDENTIFIER)
#>
#+END_SRC

** TODO code [0/0]

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="TODO",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:

<<xxEwCRi3>> *Index:* *[E]* [[upllexho][Extracted_Item_Base]] *[w]* [[G5g0gxVC][with_hash_evaluate]] 
- @@latex:\phantomsection@@ *=Extracted_Item_Base=*  <<upllexho>> <<sPb5NRq5Extracted_Item_Base>>
#+BEGIN_SRC julia :eval never :exports code
abstract type Extracted_Item_Base 
#+END_SRC
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::3][extract.jl:3]], [[xxEwCRi3][back to index]]
- @@latex:\phantomsection@@ *=with_hash_evaluate=*  <<G5g0gxVC>>
#+BEGIN_SRC julia :eval never :exports code
function with_hash_evaluate(comment::String,
                            boxingModule::String)::String
#+END_SRC
#+BEGIN_QUOTE
Parse and execute a Julia code snippet

The format is raw comment
#+BEGIN_EXAMPLE
# some text
#!5+6
#!rand(5)
# some text 
#+END_EXAMPLE

Example:
#+BEGIN_SRC julia
5+6
rand(5)
#+END_SRC

#+RESULTS:
| 0.37336130056919803 |
|  0.5336651179202612 |
|  0.8183375565134803 |
|  0.4596756705183185 |
|  0.6012430089831795 |

#+BEGIN_SRC julia
11
5-element Array{Float64,1}:
 0.618715
 0.303327
 0.29002 
 0.140657
 0.107546
#+END_SRC

#+RESULTS:
: 0.107546

- [ ] TODO skip output for code ending with ";"
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/evaluate.jl::48][evaluate.jl:48]], [[xxEwCRi3][back to index]]
:END:

* Unit tests

#+BEGIN_SRC julia :results output table :exports results
include("../test/runtests.jl")
#+END_SRC

#+RESULTS:
: # =WARNING:= Link target ("faa", "") not found
: Test Summary: | Pass  Total
: J4Org         |   96     96


* Design tips

** PDF export & phantomsection 

To be able to use links everywhere we use the
="@@latex:\\phantomsection@@"= tricks. See
[[https://tex.stackexchange.com/questions/44088/when-do-i-need-to-invoke-phantomsection][when-do-i-need-to-invoke-phantomsection]] for instance.

** HTML export with background

See https://github.com/JuliaEditorSupport/julia-emacs/issues/53

** Warning/Error messages

The trick is to generate Org mode comments.

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="Tokenizer",header_level=0,complete_link=true)
#+END_SRC

#+RESULTS:
:RESULTS:

<<qttA4xGs>> *Index:* *[E]* [[upqudCMd][Extracted_Function]], [[ohlzDlSN][Extracted_Item_Base]] *[e]* [[GnYv9dv4][extract_abstract]], [[HtfpKWii][extract_export]], [[Vu7W6eF0][extract_function]], [[qjG2Tni1][extract_struct]] *[s]* [[OF9S6qZP][skip_abstract_block]], [[TMik1awd][skip_comma_separated_identifiers]], [[ENs3PquH][skip_comment]], [[kPaVDqHV][skip_declaration_block]], [[PCQNXVQi][skip_function_call_block]], [[LnT8u8If][skip_identifier]], [[hrOQf2Zi][skip_issubtype_block]], [[nbJpmv0R][skip_struct_block]], [[U4f8kI7P][skip_uninformative]], [[wCMx63vo][skip_where_block]], [[wDBZFRyN][skip_whitespace]], [[GSioLgBZ][skip_whitespace_strict]] *[t]* [[gBpI3pMO][tokenized]] 
- @@latex:\phantomsection@@ *=Extracted_Function=*  <<upqudCMd>>
#+BEGIN_SRC julia :eval never :exports code
struct Extracted_Function <: Extracted_Item_Base
#+END_SRC
#+BEGIN_QUOTE
A structure to store extracted function.

See: [[Zjq8SftWExtracted_Item_Base][abstract Extracted_Item_Base]], [[Zjq8SftWextract_function][extract_function(...)]]
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::75][extract.jl:75]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=Extracted_Item_Base=*  <<ohlzDlSN>> <<Zjq8SftWExtracted_Item_Base>>
#+BEGIN_SRC julia :eval never :exports code
abstract type Extracted_Item_Base 
#+END_SRC
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::3][extract.jl:3]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=extract_abstract=*  <<GnYv9dv4>>
#+BEGIN_SRC julia :eval never :exports code
function extract_abstract(tok::Tokenized,idx::Int)::Union{Void,Extracted_Abstract}
#+END_SRC
#+BEGIN_QUOTE
Extract abstract type
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::185][extract.jl:185]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=extract_export=*  <<HtfpKWii>>
#+BEGIN_SRC julia :eval never :exports code
function extract_export(tok::Tokenized,idx::Int)::Union{Void,Extracted_Export}
#+END_SRC
#+BEGIN_QUOTE
Extract export
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::157][extract.jl:157]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=extract_function=*  <<Vu7W6eF0>> <<Zjq8SftWextract_function>>
#+BEGIN_SRC julia :eval never :exports code
function extract_function(tok::Tokenized,idx::Int)::Union{Void,Extracted_Function}
#+END_SRC
#+BEGIN_QUOTE
Extract function
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::87][extract.jl:87]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=extract_struct=*  <<qjG2Tni1>>
#+BEGIN_SRC julia :eval never :exports code
function extract_struct(tok::Tokenized,idx::Int)::Union{Void,Extracted_Struct}
#+END_SRC
#+BEGIN_QUOTE
Extract struct
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::131][extract.jl:131]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_abstract_block=*  <<OF9S6qZP>>
#+BEGIN_SRC julia :eval never :exports code
function skip_abstract_block(tok::Tokenized,idx::Int;
                             identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & abstract type block
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::385][tokenizer.jl:385]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_comma_separated_identifiers=*  <<TMik1awd>>
#+BEGIN_SRC julia :eval never :exports code
function skip_comma_separated_identifiers(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a comma separated sequence of identifiers A,A.B.C,A.B{...}
Does not move is comma separeted identifier not found
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::231][tokenizer.jl:231]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_comment=*  <<ENs3PquH>>
#+BEGIN_SRC julia :eval never :exports code
function skip_comment(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip comment
-> replaced by skip uninformative
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::41][tokenizer.jl:41]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_declaration_block=*  <<kPaVDqHV>>
#+BEGIN_SRC julia :eval never :exports code
function skip_declaration_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a declaration block ::identifier{...}
Does not move in case of identification failure
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::282][tokenizer.jl:282]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_function_call_block=*  <<PCQNXVQi>>
#+BEGIN_SRC julia :eval never :exports code
function skip_function_call_block(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a function call block identifier{...}(....)
Does not move in case of identification failure
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::301][tokenizer.jl:301]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_identifier=*  <<LnT8u8If>>
#+BEGIN_SRC julia :eval never :exports code
function skip_identifier(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & identifier A or A.B.C or A.B{...}
Returns (name,idx) if prod
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::183][tokenizer.jl:183]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_issubtype_block=*  <<hrOQf2Zi>>
#+BEGIN_SRC julia :eval never :exports code
function skip_issubtype_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & issubtype indentifier
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::327][tokenizer.jl:327]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_struct_block=*  <<nbJpmv0R>>
#+BEGIN_SRC julia :eval never :exports code
function skip_struct_block(tok::Tokenized,idx::Int;
                          identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & structure block
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::349][tokenizer.jl:349]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_uninformative=*  <<U4f8kI7P>>
#+BEGIN_SRC julia :eval never :exports code
function skip_uninformative(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip whitespace 
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::51][tokenizer.jl:51]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_where_block=*  <<wCMx63vo>>
#+BEGIN_SRC julia :eval never :exports code
function skip_where_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a where block (where {...} or where A,B
Does not move is comma separeted identifier not found
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::258][tokenizer.jl:258]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_whitespace=*  <<wDBZFRyN>>
#+BEGIN_SRC julia :eval never :exports code
function skip_whitespace(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip comment + whitespace 
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::60][tokenizer.jl:60]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=skip_whitespace_strict=*  <<GSioLgBZ>>
#+BEGIN_SRC julia :eval never :exports code
function skip_whitespace_strict(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip whitespace
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::121][tokenizer.jl:121]], [[qttA4xGs][back to index]]
- @@latex:\phantomsection@@ *=tokenized=*  <<gBpI3pMO>>
#+BEGIN_SRC julia :eval never :exports code
tokenized(s::String)
#+END_SRC
#+BEGIN_QUOTE
Defines a convenient method to tokenize a =String=
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::7][tokenizer.jl:7]], [[qttA4xGs][back to index]]
:END:




