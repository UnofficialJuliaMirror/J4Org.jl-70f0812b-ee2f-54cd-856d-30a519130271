#+SETUPFILE: ./Setup/setupFile.org
#+TITLE: J4Org Package
#+FILETAGS: Julia
#+PROPERTY: header-args:julia :session *JuliaDoc_session* :exports code :eval no-export
#+HTML_HEAD_EXTRA: <style type="text/css"> blockquote {background:#EEEEEE; padding: 3px 13px}    </style>
#+HTML_HEAD_EXTRA: <style type="text/css"> pre {background:#EEEEEE; padding: 3px 13px}    </style>

#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[]{
  bgcolor=bg,
  breaklines=true,
  breakanywhere=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

* Introduction

Defines a the *J4Org.jl* package, using [[https://github.com/KristofferC/Tokenize.jl/][Tokenize.jl]], to generate Julia
code documentation into Org-Mode document.

** Minimal requirements 

You need [[https://orgmode.org/][Org-Mode]] plus [[https://github.com/gjkerns/ob-julia/blob/master/ob-julia-doc.org][ob-julia.el]], which has [[http://stat.ethz.ch/ESS/index.php?Section=download][ESS]] as dependence, to be
installed. A minimal =.emacs= file can be defined as follows:

#+BEGIN_SRC emacs-lisp :tangle yes :tangle ./JuliaDoc.el
(package-initialize)

(require 'ess-site)
;; if required
;; (setq  inferior-julia-program-name "/path/to/julia-release-basic")

(require 'org)
;; *replace me* with your own ob-julia.el file location 
(add-to-list 'load-path "~/GitLab/WorkingWithOrgMode/EmacsFiles")
;; babel configuration
(setq org-confirm-babel-evaluate nil)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((julia . t)))
#+END_SRC

#+RESULTS:

* Usage examples

Let's use *J4Org.jl* for self-documentation, =API= functions

#+BEGIN_SRC julia :results output drawer :eval no-export :exports both
using Revise
using J4Org
initialize_boxing_module(usedModules=["J4Org"])
#+END_SRC

#+RESULTS:
:RESULTS:


ERROR: AssertionError: Tried to define an already existing module, maybe use the force=true kwarg
Stacktrace:
 [1] #initialize_boxing_module#24(::String, ::Array{String,1}, ::Bool, ::Function) at /home/picaud/.julia/v0.6/J4Org/src/evaluate.jl:42
 [2] (::J4Org.#kw##initialize_boxing_module)(::Array{Any,1}, ::J4Org.#initialize_boxing_module) at ./<missing>:0
:END:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports both
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="API",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:

<<5VZ66qB5>> *Index:* *[c]* [[c8qLmOgx][create_documented_item_array]], [[KJygJnEo][create_documented_item_array_dir]] *[e]* [[50M6oZR9][export]] *[i]* [[OyWzMyTQ][initialize_boxing_module]] *[p]* [[sudYS3gK][print_org_doc]] 
- @@latex:\phantomsection@@ *=create_documented_item_array=*  <<c8qLmOgx>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename::String)::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a file from its *filename* and returns an array of documented items.
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::89][documented_item.jl:89]], [[5VZ66qB5][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename_list::Array{String,1})::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a files and returns an array of documented items.

*Usage example:* (attention to ; separator)
#+BEGIN_SRC julia
create_documented_item_array([file1;file2;...])
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::128][documented_item.jl:128]], [[5VZ66qB5][back to index]]
- @@latex:\phantomsection@@ *=create_documented_item_array_dir=*  <<KJygJnEo>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array_dir(dirname::String)
#+END_SRC
#+BEGIN_QUOTE
Reads all jl files in a directory
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::147][documented_item.jl:147]], [[5VZ66qB5][back to index]]
- @@latex:\phantomsection@@ *=export=*  <<50M6oZR9>>
#+BEGIN_SRC julia :eval never :exports code
export create_documented_item_array_dir, print_org_doc
#+END_SRC
#+BEGIN_QUOTE
Exported symbols
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/J4Org.jl::3][J4Org.jl:3]], [[5VZ66qB5][back to index]]
- @@latex:\phantomsection@@ *=initialize_boxing_module=*  <<OyWzMyTQ>>
#+BEGIN_SRC julia :eval never :exports code
function initialize_boxing_module(;boxingModule::String="BoxingModule",usedModules::Vector{String}=String[],force::Bool=false)::Void
#+END_SRC
#+BEGIN_QUOTE
Initialize a boxing module. This module is used to run Julia comment
code snippet (tagged by #!)
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/evaluate.jl::17][evaluate.jl:17]], [[5VZ66qB5][back to index]]
- @@latex:\phantomsection@@ *=print_org_doc=*  <<sudYS3gK>> <<Hz9fxO54print_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule")
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_EXAMPLE
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(tag="API",header_level=0)
,#+END_SRC
#+END_EXAMPLE

*Arguments:*
- *link_prefix:* allows to add a prefix to extra link (#+tags    L:extra_link).
                 this is can be useful to avoid link name conflict when performing local doc extraction.
- *complete_link:* if true, try to fix link without target by adding extra items
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/main.jl::346][main.jl:346]], [[5VZ66qB5][back to index]]
:END:


** Tips

*** Org-mode block in comment

For the moment these blocks are left unchanged. For the moment only EXAMPLE blocks work. For instance:
# CAVEAT: can not use RESULT because of NESTED EXAMPLE BLOCKS (org is lost!)
#+BEGIN_EXAMPLE
# Prints doc. This is the main function of the =J4Org= package.
#
# *Org-Mode Usage example:*
# #+BEGIN_EXAMPLE
# ,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
# documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
# print_org_doc(tag="API",header_level=0)
# ,#+END_SRC
# #+END_EXAMPLE
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::String="",
                       identifier::String="",
                       header_level::Int=0) = ...
#+END_EXAMPLE





This will generate this doc: 
#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,identifier="print_org_doc",header_level=-1)
#+END_SRC

#+RESULTS:
:RESULTS:
ERROR: MethodError: no method matching start(::Void)
Closest candidates are:
  start(!Matched::SimpleVector) at essentials.jl:258
  start(!Matched::Base.MethodList) at reflection.jl:560
  start(!Matched::ExponentialBackOff) at error.jl:107
  ...
Stacktrace:
 [1] #writedlm#18(::Array{Any,1}, ::Function, ::IOStream, ::Void, ::Char) at ./datafmt.jl:673
 [2] #20 at ./datafmt.jl:683 [inlined]
 [3] open(::Base.DataFmt.##20#21{Array{Any,1},Void,Char}, ::String, ::String) at ./iostream.jl:152
 [4] #writecsv#23(::Array{Any,1}, ::Function, ::String, ::Void) at ./datafmt.jl:705
 [5] writecsv(::String, ::Void) at ./datafmt.jl:705

 @@latex:\phantomsection@@  <<speLT1Smprint_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule")
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_EXAMPLE
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(tag="API",header_level=0)
,#+END_SRC
#+END_EXAMPLE

*Arguments:*
- *link_prefix:* allows to add a prefix to extra link (#+tags    L:extra_link).
                 this is can be useful to avoid link name conflict when performing local doc extraction.
- *complete_link:* if true, try to fix link without target by adding extra items
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/main.jl::346][main.jl:346]]
:END:

*** Julia code block in comment 
    :PROPERTIES:
    :ID:       f896399f-bd8f-4d68-b4ae-f67ed6a313ef
    :END:

You can define Julia code in comment:

#+INCLUDE: "./code_examples/meaninglesscode.jl" src julia

The generated code is:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items_docs=create_documented_item_array_dir("./code_examples/");
print_org_doc(documented_items_docs,tag="foo_doc",header_level=-1)
#+END_SRC

#+RESULTS:
:RESULTS:


#+BEGIN_SRC julia :eval never :exports code
foo(x::Int)
#+END_SRC
#+BEGIN_QUOTE
You can redefine the foo function:

#+BEGIN_SRC julia
# julia code example
foo(x::Float64) = 1
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:./code_examples/meaninglesscode.jl::1][meaninglesscode.jl:1]]
:END:

*Note:* maybe in the future Julia SRC blocks will be evaluated,
 however this functionality is not available for the moment.

*** Obsolete stuff

You can use 
#+BEGIN_EXAMPLE
- [ ] todo 
#+END_EXAMPLE
in a comment block 

for instance
#+BEGIN_EXAMPLE
,#+Obsolete
#
#  - [ ] remove me (to be replaced by find_tag)
#
function is_tag(tok::Tokenized,idx::Int)::Bool
#+END_EXAMPLE



* Documentation

** API

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="API",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:

<<X2gYw2dG>> *Index:* *[c]* [[5C7R0luP][create_documented_item_array]], [[ThWZdowv][create_documented_item_array_dir]] *[e]* [[tsmBt19N][export]] *[i]* [[fNR8GGaj][initialize_boxing_module]] *[p]* [[xTS3CMHd][print_org_doc]] 
- @@latex:\phantomsection@@ *=create_documented_item_array=*  <<5C7R0luP>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename::String)::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a file from its *filename* and returns an array of documented items.
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::89][documented_item.jl:89]], [[X2gYw2dG][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename_list::Array{String,1})::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a files and returns an array of documented items.

*Usage example:* (attention to ; separator)
#+BEGIN_SRC julia
create_documented_item_array([file1;file2;...])
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::128][documented_item.jl:128]], [[X2gYw2dG][back to index]]
- @@latex:\phantomsection@@ *=create_documented_item_array_dir=*  <<ThWZdowv>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array_dir(dirname::String)
#+END_SRC
#+BEGIN_QUOTE
Reads all jl files in a directory
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::147][documented_item.jl:147]], [[X2gYw2dG][back to index]]
- @@latex:\phantomsection@@ *=export=*  <<tsmBt19N>>
#+BEGIN_SRC julia :eval never :exports code
export create_documented_item_array_dir, print_org_doc
#+END_SRC
#+BEGIN_QUOTE
Exported symbols
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/J4Org.jl::3][J4Org.jl:3]], [[X2gYw2dG][back to index]]
- @@latex:\phantomsection@@ *=initialize_boxing_module=*  <<fNR8GGaj>>
#+BEGIN_SRC julia :eval never :exports code
function initialize_boxing_module(;boxingModule::String="BoxingModule",usedModules::Vector{String}=String[],force::Bool=false)::Void
#+END_SRC
#+BEGIN_QUOTE
Initialize a boxing module. This module is used to run Julia comment
code snippet (tagged by #!)
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/evaluate.jl::17][evaluate.jl:17]], [[X2gYw2dG][back to index]]
- @@latex:\phantomsection@@ *=print_org_doc=*  <<xTS3CMHd>> <<ZyzDNStjprint_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule")
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_EXAMPLE
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(tag="API",header_level=0)
,#+END_SRC
#+END_EXAMPLE

*Arguments:*
- *link_prefix:* allows to add a prefix to extra link (#+tags    L:extra_link).
                 this is can be useful to avoid link name conflict when performing local doc extraction.
- *complete_link:* if true, try to fix link without target by adding extra items
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/main.jl::346][main.jl:346]], [[X2gYw2dG][back to index]]
:END:


* Internal documention
** Error management

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="Error",tag_to_ignore=["Documented_Item"],header_level=0,complete_link=false)
#+END_SRC

#+RESULTS:
:RESULTS:

<<ZvvmTOs7>> *Index:* *[c]* [[vNk4O9li][create_file_org_link]] *[w]* [[0D4E04o4][warning_message]] 
- @@latex:\phantomsection@@ *=create_file_org_link=*  <<vNk4O9li>>
#+BEGIN_SRC julia :eval never :exports code
function create_file_org_link(filename::String,line::Int=0)::String
#+END_SRC
#+BEGIN_QUOTE
Generate a org compatible link to file
*Examples:*
#+BEGIN_SRC julia
J4Org.create_file_org_link("/path/file.txt")
J4Org.create_file_org_link("/path/file.txt",10)
#+END_SRC

#+RESULTS:
| [ |
| [ |
| f |
| i |
| l |
| e |
| : |
| p |
| a |
| t |
| h |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| : |
| 1 |
| 0 |
| ] |
| [ |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| 1 |
| 0 |
| ] |
| ] |

#+BEGIN_SRC julia
"[[file:/path/file.txt][file.txt]]"
"[[file:/path/file.txt::10][file.txt:10]]"
#+END_SRC

#+RESULTS:
| [ |
| [ |
| f |
| i |
| l |
| e |
| : |
| p |
| a |
| t |
| h |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| : |
| 1 |
| 0 |
| ] |
| [ |
| f |
| i |
| l |
| e |
| 0 |
| t |
| x |
| t |
| : |
| 1 |
| 0 |
| ] |
| ] |

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/J4Org.jl::20][J4Org.jl:20]], [[ZvvmTOs7][back to index]]
- @@latex:\phantomsection@@ *=warning_message=*  <<0D4E04o4>>
#+BEGIN_SRC julia :eval never :exports code
function warning_message(message::String)::Void
#+END_SRC
#+BEGIN_QUOTE
You must use this function to print error message,
It generates a message of the form
#+BEGIN_EXAMPLE 
# =WARNING:= message
#+END_EXAMPLE
which is an Org mode *comment*, hence it does not affect function output.
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/J4Org.jl::8][J4Org.jl:8]], [[ZvvmTOs7][back to index]]
:END:



#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="Links",header_level=0,complete_link=true)
#+END_SRC

#+RESULTS:
:RESULTS:

<<4SezrCcK>> *Index:* *[D]* [[59GAqnrE][Documented_Item]] *[c]* [[dWvlMIK7][clean_extracted_links]], [[ysdyHaVr][create_file_org_link]] *[d]* [[v93JABon][doc_link_substituion]] *[e]* [[2eKgXs8g][extract_links]] *[g]* [[yT6juWud][get_items_with_link_target]] 
- @@latex:\phantomsection@@ *=Documented_Item=*  <<59GAqnrE>> <<2eOkHVZeDocumented_Item>>
#+BEGIN_SRC julia :eval never :exports code
struct Documented_Item
#+END_SRC
#+BEGIN_QUOTE
A *central* structure containing documented item
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::1][documented_item.jl:1]], [[4SezrCcK][back to index]]
- @@latex:\phantomsection@@ *=clean_extracted_links=*  <<dWvlMIK7>>
#+BEGIN_SRC julia :eval never :exports code
function clean_extracted_links(toClean::Vector{Tuple{String,String}})::Vector{Tuple{String,String}}
#+END_SRC
#+BEGIN_QUOTE
This function clean extracted links by removing duplicates

See: [[2eOkHVZeextract_links_string][extract_links(...)]]
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/links.jl::60][links.jl:60]], [[4SezrCcK][back to index]]
- @@latex:\phantomsection@@ *=create_file_org_link=*  <<ysdyHaVr>>
#+BEGIN_SRC julia :eval never :exports code
function create_file_org_link(di::Documented_Item)::String
#+END_SRC
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/documented_item.jl::49][documented_item.jl:49]], [[4SezrCcK][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function create_file_org_link(filename::String,line::Int=0)::String
#+END_SRC
#+BEGIN_QUOTE
Generate a org compatible link to file
*Examples:*
#+BEGIN_SRC julia
J4Org.create_file_org_link("/path/file.txt")
J4Org.create_file_org_link("/path/file.txt",10)
#+END_SRC
#+BEGIN_SRC julia
"[[file:/path/file.txt][file.txt]]"
"[[file:/path/file.txt::10][file.txt:10]]"
#+END_SRC
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/J4Org.jl::20][J4Org.jl:20]], [[4SezrCcK][back to index]]
- @@latex:\phantomsection@@ *=doc_link_substituion=*  <<v93JABon>> <<2eOkHVZedoc_link_substituion>>
#+BEGIN_SRC julia :eval never :exports code
function doc_link_substituion(doc::String,di_array::Array{Documented_Item,1},link_prefix::String)::String
#+END_SRC
#+BEGIN_QUOTE
From doc string performs links substitution

- check if there are links in the doc, eventually return unmodified doc string 
- for each link check if it exists in di_array
  - yes, replace ​[​[link_target][]] by ​[​[link_prefix_link_target][identifier]] to create a valid OrgMode link.
  - no,  replace ​[​[link_target][]] by _link_target_ to create an inactive link 

*Note:* in order to do not interfere with org mode link we only process "links" of the form "[[something][]]"
        see https://orgmode.org/manual/Link-format.html

*Note:* to be able to write a "unactive" link, use C-x 8 RET 200b
        (see: https://emacs.stackexchange.com/a/16702)
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/links.jl::89][links.jl:89]], [[4SezrCcK][back to index]]
- @@latex:\phantomsection@@ *=extract_links=*  <<2eKgXs8g>> <<2eOkHVZeextract_links_string>>
#+BEGIN_SRC julia :eval never :exports code
function extract_links(input::String)::Vector{Tuple{String,String}}
#+END_SRC
#+BEGIN_QUOTE
This function returns the list of links found in the string. It
returns nothing if no link is found

#+BEGIN_SRC julia
s="# some text [[some_target][]] another one [[link_target][link_name]]\n and a last one [[a4][b1]]"
J4Org.extract_links(s)
#+END_SRC

#+BEGIN_EXAMPLE
1-element Array{Tuple{String,String},1}:
 ("some_target", "")         
#+END_EXAMPLE

*Caveat:* only use links of the forme ​"[​[something][]]", which are not
          valid Org mode links, see [[2eOkHVZedoc_link_substituion][doc_link_substituion(...)]]

*Test link:* [[2eOkHVZedoc_link_substituion][doc_link_substituion(...)]]
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/links.jl::2][links.jl:2]], [[4SezrCcK][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function extract_links(di_array::Array{Documented_Item,1})::Vector{Tuple{String,String}}
#+END_SRC
#+BEGIN_QUOTE
This function is like [[2eOkHVZeextract_links_string][extract_links(...)]], except that is
process an array of [[2eOkHVZeDocumented_Item][struct Documented_Item]]
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/links.jl::45][links.jl:45]], [[4SezrCcK][back to index]]
- @@latex:\phantomsection@@ *=get_items_with_link_target=*  <<yT6juWud>>
#+BEGIN_SRC julia :eval never :exports code
function get_items_with_link_target(link_target::String,di_array::Array{Documented_Item,1})::Vector{Int}
#+END_SRC
#+BEGIN_QUOTE
Returns the indices of [[2eOkHVZeDocumented_Item][struct Documented_Item]] containing the
link_target (have a tag line with L:link_target)

*Note:* a normal situation is to have zero or one indices. Several
indices means that we do not have a unique target.
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/links.jl::70][links.jl:70]], [[4SezrCcK][back to index]]
:END:

** Find Tag

The role of this group is to scan tokenized code to find tags.

#+BEGIN_EXAMPLE
#+Tags... L:extra_link
#+END_EXAMPLE

Then extracts information like =Tags= list and =extra_link= name.

 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="FindTag",header_level=0,complete_link=false)
 #+END_SRC

 #+RESULTS:
 :RESULTS:

 <<A1hL6n5O>> *Index:* *[E]* [[gzg58DfU][Extract_Tag_Result]] *[e]* [[AkJQ3KqK][extract_tag]] *[f]* [[rY3KxUjL][find_tag]] *[l]* [[UDsamTJ9][line]], [[WPr4JLvM][link]] *[s]* [[QkbpbMBc][skip]] *[t]* [[aNlQRkrj][tag_idx]], [[j0FWrxuT][tags]] 
 - @@latex:\phantomsection@@ *=Extract_Tag_Result=*  <<gzg58DfU>>
 #+BEGIN_SRC julia :eval never :exports code
 struct Extract_Tag_Result <: Extracted_Item_Base
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::2][find_tag.jl:2]], [[A1hL6n5O][back to index]]
 - @@latex:\phantomsection@@ *=extract_tag=*  <<AkJQ3KqK>> <<wiZD7pWxextract_tag_link>>
 #+BEGIN_SRC julia :eval never :exports code
 function extract_tag(tok::Tokenized,idx::Int)::Union{Void,Extract_Tag_Result}
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::27][find_tag.jl:27]], [[A1hL6n5O][back to index]]
 - @@latex:\phantomsection@@ *=find_tag=*  <<rY3KxUjL>> <<wiZD7pWxfind_tag_master>>
 #+BEGIN_SRC julia :eval never :exports code
 function find_tag(tok::Tokenized,idx::Int,predicate::Function)::Union{Void,Extract_Tag_Result}
 #+END_SRC
 #+BEGIN_QUOTE
 If some tags are found use the
 #+BEGIN_SRC julia
 predicate(r::Extract_Tag_Result)::Bool
 #+END_SRC

 #+RESULTS:

 to accept (or not) the tags

 *Returns:*
 - =(idx,Extract_Tag_Result)=: where =idx= is the position of the discovered tag
 - =(length(tok)+1,nothing)=: if no tag found
 #+END_QUOTE
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::76][find_tag.jl:76]], [[A1hL6n5O][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 function find_tag(tok::Tokenized,idx::Int)::Union{Void,Extract_Tag_Result}
 #+END_SRC
 #+BEGIN_QUOTE
 Convenience function that uses [[wiZD7pWxfind_tag_master][find_tag(...)]] with =x->true=
 predicate. It accepts all tags
 #+END_QUOTE
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::104][find_tag.jl:104]], [[A1hL6n5O][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 function find_tag(tok::Tokenized,idx::Int,tag::String)::Union{Void,Extract_Tag_Result}
 #+END_SRC
 #+BEGIN_QUOTE
 Convenience function that uses  find_tag_master find_tag  with a
 predicate that checks for *Tag* existence.
 #+END_QUOTE
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::112][find_tag.jl:112]], [[A1hL6n5O][back to index]]
 - @@latex:\phantomsection@@ *=line=*  <<UDsamTJ9>>
 #+BEGIN_SRC julia :eval never :exports code
 line(o::Extract_Tag_Result)::Int
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::22][find_tag.jl:22]], [[A1hL6n5O][back to index]]
 - @@latex:\phantomsection@@ *=link=*  <<WPr4JLvM>>
 #+BEGIN_SRC julia :eval never :exports code
 link(o::Extract_Tag_Result)::String
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::19][find_tag.jl:19]], [[A1hL6n5O][back to index]]
 - @@latex:\phantomsection@@ *=skip=*  <<QkbpbMBc>>
 #+BEGIN_SRC julia :eval never :exports code
 skip(o::Extract_Tag_Result)::Int
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::13][find_tag.jl:13]], [[A1hL6n5O][back to index]]
 - @@latex:\phantomsection@@ *=tag_idx=*  <<aNlQRkrj>>
 #+BEGIN_SRC julia :eval never :exports code
 tag_idx(o::Extract_Tag_Result)::Int
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::10][find_tag.jl:10]], [[A1hL6n5O][back to index]]
 - @@latex:\phantomsection@@ *=tags=*  <<j0FWrxuT>>
 #+BEGIN_SRC julia :eval never :exports code
 tags(o::Extract_Tag_Result)::Array{String,1}
 #+END_SRC
 [[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/find_tag.jl::16][find_tag.jl:16]], [[A1hL6n5O][back to index]]
 :END:

* TODO list [0/2]
** TODO development [5/10]
- [ ] add a function to show link and targets & detect useless link_target
- [ ] search for "export" keyword to annotate documented item 
- [ ] even if complete_link = false, search for target in order to do pretty print (information like struct etc...)
- [X] use extracted tag in DocumentedItem
- [X] allows tag list "#+tag1, tag2"
- [X] add prefix to extra link: <<link>> -> <<prefix_link>>
- [X] finish parsing and code cleaning 
- [ ] add an option to extract code body
- [ ] :RESULT: bug
- [X] fix ugly PDF link 
- [ ] detect constructor
- [X] for the index, lexico sort: l = L (sort not sensitive to capital)
- [ ] allows an alternative syntax (maybe not a good idea?)
#+BEGIN_SRC julia :eval never :exports code 
#<Tokenizer,Internal
# common doc
is_structure(tok::Tokenized,idx::Int)::Bool = (exactkind(tok[idx])==Tokenize.Tokens.STRUCT)
is_function(tok::Tokenized,idx::Int)::Bool = (exactkind(tok[idx])==Tokenize.Tokens.FUNCTION)
is_comment(tok::Tokenized,idx::Int)::Bool = (kind(tok[idx])==Tokenize.Tokens.COMMENT)
is_whitespace(tok::Tokenized,idx::Int)::Bool = (kind(tok[idx])==Tokenize.Tokens.WHITESPACE)
is_identifier(tok::Tokenized,idx::Int)::Bool = (exactkind(tok[idx])==Tokenize.Tokens.IDENTIFIER)
#>
#+END_SRC

** TODO code [0/0]

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="TODO",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:

<<EA26Z5qF>> *Index:* *[E]* [[YDX4jbbJ][Extracted_Item_Base]] *[w]* [[ncrkVkzn][with_hash_evaluate]] 
- @@latex:\phantomsection@@ *=Extracted_Item_Base=*  <<YDX4jbbJ>> <<HlSICzrGExtracted_Item_Base>>
#+BEGIN_SRC julia :eval never :exports code
abstract type Extracted_Item_Base 
#+END_SRC
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::3][extract.jl:3]], [[EA26Z5qF][back to index]]
- @@latex:\phantomsection@@ *=with_hash_evaluate=*  <<ncrkVkzn>>
#+BEGIN_SRC julia :eval never :exports code
function with_hash_evaluate(comment::String,
                            boxingModule::String)::String
#+END_SRC
#+BEGIN_QUOTE
Parse and execute a Julia code snippet

The format is raw comment
#+BEGIN_EXAMPLE
# some text
#!5+6
#!rand(5)
# some text 
#+END_EXAMPLE

Example:
#+BEGIN_SRC julia
5+6
rand(5)
#+END_SRC

#+RESULTS:
| 0.10290552873465542 |
| 0.11016172971204474 |
|  0.9621431017015925 |
|  0.8414420209884048 |
|  0.3714649327950268 |

#+BEGIN_SRC julia
11
5-element Array{Float64,1}:
 0.536283
 0.668383
 0.559368
 0.213578
 0.991541
#+END_SRC

#+RESULTS:

- [ ] TODO skip output for code ending with ";"
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/evaluate.jl::48][evaluate.jl:48]], [[EA26Z5qF][back to index]]
:END:

* Unit tests

#+BEGIN_SRC julia :results output table :exports results
include("../test/runtests.jl")
#+END_SRC

#+RESULTS:
: 
: # =WARNING:= Link target ("faa", "") not found
: Test Summary: | Pass  Total
: J4Org         |   96     96



* Designs tips

** PDF export & phantomsection 

To be able to use links everywhere we use the
="@@latex:\\phantomsection@@"= tricks. See
[[https://tex.stackexchange.com/questions/44088/when-do-i-need-to-invoke-phantomsection][when-do-i-need-to-invoke-phantomsection]] for instance.

** HTML export with background

See https://github.com/JuliaEditorSupport/julia-emacs/issues/53

** Warning/Error messages

The trick is to generate Org mode comments.

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/");
print_org_doc(documented_items,tag="Tokenizer",header_level=0,complete_link=true)
#+END_SRC

#+RESULTS:
:RESULTS:

<<bxPwdP5r>> *Index:* *[E]* [[aLqyu4hD][Extracted_Function]], [[5Ed0cWEO][Extracted_Item_Base]] *[e]* [[FW1di4Hv][extract_abstract]], [[3VlKrfXP][extract_export]], [[bXcqdaeH][extract_function]], [[B29KeMYi][extract_struct]] *[s]* [[Yz9eHlZp][skip_abstract_block]], [[fnuivvYP][skip_comma_separated_identifiers]], [[YEwq9cKJ][skip_comment]], [[Fflr0WYL][skip_declaration_block]], [[QXMGFlPs][skip_function_call_block]], [[nUR8PgGj][skip_identifier]], [[TOHgw3NA][skip_issubtype_block]], [[ecyvr1SI][skip_struct_block]], [[TKZLIIjK][skip_uninformative]], [[ooxYfsos][skip_where_block]], [[bHB76fLD][skip_whitespace]], [[pnCV5TLl][skip_whitespace_strict]] *[t]* [[IbCVimIM][tokenized]] 
- @@latex:\phantomsection@@ *=Extracted_Function=*  <<aLqyu4hD>>
#+BEGIN_SRC julia :eval never :exports code
struct Extracted_Function <: Extracted_Item_Base
#+END_SRC
#+BEGIN_QUOTE
A structure to store extracted function.

See: [[46OWl1mmExtracted_Item_Base][abstract Extracted_Item_Base]], [[46OWl1mmextract_function][extract_function(...)]]
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::75][extract.jl:75]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=Extracted_Item_Base=*  <<5Ed0cWEO>> <<46OWl1mmExtracted_Item_Base>>
#+BEGIN_SRC julia :eval never :exports code
abstract type Extracted_Item_Base 
#+END_SRC
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::3][extract.jl:3]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=extract_abstract=*  <<FW1di4Hv>>
#+BEGIN_SRC julia :eval never :exports code
function extract_abstract(tok::Tokenized,idx::Int)::Union{Void,Extracted_Abstract}
#+END_SRC
#+BEGIN_QUOTE
Extract abstract type
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::185][extract.jl:185]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=extract_export=*  <<3VlKrfXP>>
#+BEGIN_SRC julia :eval never :exports code
function extract_export(tok::Tokenized,idx::Int)::Union{Void,Extracted_Export}
#+END_SRC
#+BEGIN_QUOTE
Extract export
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::157][extract.jl:157]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=extract_function=*  <<bXcqdaeH>> <<46OWl1mmextract_function>>
#+BEGIN_SRC julia :eval never :exports code
function extract_function(tok::Tokenized,idx::Int)::Union{Void,Extracted_Function}
#+END_SRC
#+BEGIN_QUOTE
Extract function
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::87][extract.jl:87]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=extract_struct=*  <<B29KeMYi>>
#+BEGIN_SRC julia :eval never :exports code
function extract_struct(tok::Tokenized,idx::Int)::Union{Void,Extracted_Struct}
#+END_SRC
#+BEGIN_QUOTE
Extract struct
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/extract.jl::131][extract.jl:131]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_abstract_block=*  <<Yz9eHlZp>>
#+BEGIN_SRC julia :eval never :exports code
function skip_abstract_block(tok::Tokenized,idx::Int;
                             identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & abstract type block
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::385][tokenizer.jl:385]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_comma_separated_identifiers=*  <<fnuivvYP>>
#+BEGIN_SRC julia :eval never :exports code
function skip_comma_separated_identifiers(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a comma separated sequence of identifiers A,A.B.C,A.B{...}
Does not move is comma separeted identifier not found
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::231][tokenizer.jl:231]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_comment=*  <<YEwq9cKJ>>
#+BEGIN_SRC julia :eval never :exports code
function skip_comment(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip comment
-> replaced by skip uninformative
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::41][tokenizer.jl:41]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_declaration_block=*  <<Fflr0WYL>>
#+BEGIN_SRC julia :eval never :exports code
function skip_declaration_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a declaration block ::identifier{...}
Does not move in case of identification failure
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::282][tokenizer.jl:282]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_function_call_block=*  <<QXMGFlPs>>
#+BEGIN_SRC julia :eval never :exports code
function skip_function_call_block(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a function call block identifier{...}(....)
Does not move in case of identification failure
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::301][tokenizer.jl:301]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_identifier=*  <<nUR8PgGj>>
#+BEGIN_SRC julia :eval never :exports code
function skip_identifier(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & identifier A or A.B.C or A.B{...}
Returns (name,idx) if prod
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::183][tokenizer.jl:183]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_issubtype_block=*  <<TOHgw3NA>>
#+BEGIN_SRC julia :eval never :exports code
function skip_issubtype_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & issubtype indentifier
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::327][tokenizer.jl:327]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_struct_block=*  <<ecyvr1SI>>
#+BEGIN_SRC julia :eval never :exports code
function skip_struct_block(tok::Tokenized,idx::Int;
                          identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & structure block
Does not move is identifier not found

#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::349][tokenizer.jl:349]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_uninformative=*  <<TKZLIIjK>>
#+BEGIN_SRC julia :eval never :exports code
function skip_uninformative(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip whitespace 
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::51][tokenizer.jl:51]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_where_block=*  <<ooxYfsos>>
#+BEGIN_SRC julia :eval never :exports code
function skip_where_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a where block (where {...} or where A,B
Does not move is comma separeted identifier not found
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::258][tokenizer.jl:258]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_whitespace=*  <<bHB76fLD>>
#+BEGIN_SRC julia :eval never :exports code
function skip_whitespace(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip comment + whitespace 
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::60][tokenizer.jl:60]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=skip_whitespace_strict=*  <<pnCV5TLl>>
#+BEGIN_SRC julia :eval never :exports code
function skip_whitespace_strict(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip whitespace
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::121][tokenizer.jl:121]], [[bxPwdP5r][back to index]]
- @@latex:\phantomsection@@ *=tokenized=*  <<IbCVimIM>>
#+BEGIN_SRC julia :eval never :exports code
tokenized(s::String)
#+END_SRC
#+BEGIN_QUOTE
Defines a convenient method to tokenize a =String=
#+END_QUOTE
[[file:/home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/tokenizer.jl::7][tokenizer.jl:7]], [[bxPwdP5r][back to index]]
:END:




